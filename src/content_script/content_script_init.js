function injectExtension() {
  // Note: To combat async issues, we generate code for release
  // On release set this condition to true and generate code using build script
  if (false) {
    var s = document.createElement('script');
    var code_to_inject = `var messageType = {\n  PIXEL_INSPECTOR : \"pixelInspector\",\n  CALL_STACK: \"callStack\",\n  CALL_STACK_DRAW: \"callStackDraw\",\n  GET_CALL_STACK : \"getCallStack\",\n  GET_CALL_STACK_DRAW : \"getCallStackDraw\",\n  TOGGLE_CALL_STACK : \"toggleCallStack\",\n  TOGGLE_FUNCTION_HISTOGRAM : \"toggleFunctionHistogram\",\n  FUNCTION_HISTOGRAM : \"functionHistogram\",\n  TOGGLE_PROGRAM_USAGE_COUNT : \"toggleProgramUsageCount\",\n  RESET_PROGRAM_USAGE_COUNT : \"resetProgramUsageCount\",\n  GET_PROGRAM_USAGE_COUNT : \"getProgramUsageCount\",\n  TOGGLE_DUPLICATE_PROGRAM_USAGE : \"toggleDuplicateProgramUsage\",\n  GET_DUPLICATE_PROGRAM_USAGE : \"getDuplicateProgramUse\",\n  RESET_DUPLICATE_PROGRAM_USAGE : \"resetDuplicateProgramUsage\",\n  GET_CONTEXTS : \"getContexts\",\n  CONTEXTS : \"contexts\",\n  GET_TEXTURE : \"texture\",\n  GET_TEXTURES : \"textures\",\n  GET_BUFFER : \"buffer\",\n  GET_BUFFERS : \"buffers\",\n  GET_FRAME_BUFFER : \"frameBuffer\",\n  GET_FRAME_BUFFERS : \"frameBuffers\",\n  GET_RENDER_BUFFER : \"renderBuffer\",\n  GET_RENDER_BUFFERS : \"renderBuffers\",\n  STATE_VARS : \"stateVariables\",\n  TOGGLE_STATE_VARS : \"toggleStateVariables\",\n  FRAME_CONTROL_PLAY : \"frameControlPlay\",\n  FRAME_CONTROL_PAUSE : \"frameControlPause\",\n  FRAME_CONTROL_NEXT_FRAME : \"frameControlNextFrame\",\n  ENABLE_MIPMAP_TEXTURE : \"enableMipmapTexture\",\n  MIPMAP_TEXTURES : \"mipmapTextures\",\n  DISABLE_ALL : \"disableAll\",\n  DISABLE_ALL_CONTEXTS : \"disableAllContexts\",\n  SHADERS : \"programShaders\",\n  DEPTH_INSPECTOR : \"depthInspector\",\n}\nvar glpHelpers = (function () {\n\nhelpers = {};\n\nhelpers.guid = function() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return s4() + s4() + \'-\' + s4() + \'-\' + s4() + \'-\' +\n    s4() + \'-\' + s4() + s4() + s4();\n}\n\n_glEnums = {}\nhelpers.getGLEnumName = function(gl, e) {\n  if (Object.keys(_glEnums).length != 0) {\n    return _glEnums[e];\n  }\n\n  for (var name in gl) {\n    _glEnums[gl[name]] = name;\n  }\n  _glEnums[0] = 0;\n  return _glEnums[e];\n}\n\nhelpers.getGLArgsString = function(gl, args) {\n  if (!args) {\n    return \"\";\n  }\n\n  var argsString = \"\";\n  for (var i = 0; i < args.length; i++) {\n    if (i != 0) {\n      argsString += \", \";\n    }\n    var glEnumName = this.getGLEnumName(gl, args[i]);\n    if (typeof glEnumName == \"string\") {\n      argsString += glEnumName;\n    } else {\n      argsString += args[i];\n    }\n  }\n  return argsString;\n}\n\nhelpers.getGLArgsList = function(gl, calls) {\n  if (calls) {\n    var argsList = [];\n    for (var i = 0; i < calls.length; i++) {\n      argsList.push(this.getGLArgsString(gl, calls[i]));\n    }\n    return argsList;\n  }\n  return null;\n}\n\nhelpers.getTextureSize = function(texture) {\n    var size = {};\n    size.width = 16;\n    size.height = 16;\n\n    if (texture.texImage2DCalls) {\n        for (var i = 0; i < texture.texImage2DCalls.length; i++) {\n            var args = texture.texImage2DCalls[i];\n            if (args[1] == 0) {\n                if (args.length == 9) {\n                    size.width = Math.max(args[3], size.width);\n                    size.height = Math.max(args[4], size.height);\n                } else if (args[5]) {\n                    size.width = Math.max(args[5].width, size.width);\n                    size.height = Math.max(args[5].height, size.height);\n                }\n            }\n        }\n    }\n\n    return size;\n}\n\nreturn helpers;\n}());\nvar glpBufferViewer = function (gl) {\n  this.gl = gl;\n  this.buffers = [];\n  this.framebuffers = [];\n  this.renderbuffers = [];\n  this.boundBuffer = null;\n  this.boundFramebuffer = null;\n  this.boundRenderbuffer = null;\n}\n\n\/**\n * Sends the number of buffers created to the front end\n **\/\nglpBufferViewer.prototype.getBuffers = function() {\n  this.gl.glp().messages.sendMessage(messageType.GET_BUFFERS, { \"length\" : this.buffers.length });\n}\n\n\/**\n * Sends the number of frame buffers created to the front end\n **\/\nglpBufferViewer.prototype.getFrameBuffers = function() {\n  this.gl.glp().messages.sendMessage(messageType.GET_FRAME_BUFFERS, { \"length\" : this.framebuffers.length });\n}\n\n\/**\n * Sends the number of render buffers created to the front end\n **\/\nglpBufferViewer.prototype.getRenderBuffers = function() {\n  this.gl.glp().messages.sendMessage(messageType.GET_RENDER_BUFFERS, { \"length\" : this.renderbuffers.length });\n}\n\nglpBufferViewer.prototype.bindBuffer = function(buffer) {\n  this.boundBuffer = buffer;\n}\n\nglpBufferViewer.prototype.unbindBuffer = function() {\n  this.boundBuffer = null;\n}\n\nglpBufferViewer.prototype.bufferData = function(args) {\n  if (this.boundBuffer != null && args != null) {\n\n    if (typeof args[1] == \"number\") {\n      this.boundBuffer.buffer = new ArrayBuffer(args[1]);\n    } else {\n      this.boundBuffer.buffer = args[1].slice();\n    }\n\n  }\n}\n\nglpBufferViewer.prototype.bufferSubData = function(args) {\n  if (this.boundBuffer != null && args != null) {\n\n    if (this.boundBuffer.buffer) {\n      for (var i = 0; i < args[2].length; i++) {\n        this.boundBuffer.buffer[args[1]+i] = args[2][i];\n      }\n    }\n\n  }\n}\n\nglpBufferViewer.prototype.deleteBuffer = function(buffer) {\n  buffer.deleted = true;\n}\n\nglpBufferViewer.prototype.bindFramebuffer = function(buffer) {\n  this.boundFramebuffer = buffer;\n}\n\nglpBufferViewer.prototype.unbindFramebuffer = function() {\n  this.boundFramebuffer = null;\n}\n\nglpBufferViewer.prototype.deleteFramebuffer = function(buffer) {\n  if (buffer != null) {\n    buffer.deleted = true;\n  }\n}\n\nglpBufferViewer.prototype.framebufferRenderbuffer = function(args) {\n  if (this.boundFramebuffer != null && args != null) {\n    if (!this.boundFramebuffer.framebufferRenderbufferCalls) {\n      this.boundFramebuffer.framebufferRenderbufferCalls = [];\n    }\n    this.boundFramebuffer.framebufferRenderbufferCalls.push(args);\n\n    var renderbuffer = args[3];\n    if (renderbuffer) {\n      if (!renderbuffer.framebufferRenderbufferCalls) {\n        renderbuffer.framebufferRenderbufferCalls = [];\n      }\n      renderbuffer.framebufferRenderbufferCalls.push(args);\n    }\n  }\n}\n\nglpBufferViewer.prototype.framebufferTexture2D = function(args) {\n  if (this.boundFramebuffer != null && args != null) {\n    if (!this.boundFramebuffer.framebufferTexture2DCalls) {\n      this.boundFramebuffer.framebufferTexture2DCalls = [];\n    }\n    this.boundFramebuffer.framebufferTexture2DCalls.push(args);\n  }\n}\n\nglpBufferViewer.prototype.bindRenderbuffer = function(buffer) {\n  this.boundRenderbuffer = buffer;\n}\n\nglpBufferViewer.prototype.unbindRenderbuffer = function() {\n  this.boundRenderbuffer = null;\n}\n\nglpBufferViewer.prototype.deleteRenderbuffer = function(buffer) {\n  if (buffer != null) {\n    buffer.deleted = true;\n  }\n}\n\nglpBufferViewer.prototype.getBuffer = function(index) {\n  if (index < 0 || index >= this.buffers.length) {\n    return;\n  }\n\n  var buffer = this.buffers[index];\n\n  var source = {};\n  source.arraySrc = Array.prototype.slice.call(buffer.buffer);\n  source.deleted = buffer.deleted;\n\n  this.gl.glp().messages.sendMessage(messageType.GET_BUFFER, JSON.stringify({\n    \"index\" : index,\n    \"source\" : source,\n  }));\n}\n\nglpBufferViewer.prototype.createBase64Url = function(framebuffer) {\n\n  var data = null;\n\n  var boundFramebuffer = this.boundFramebuffer;\n  this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, framebuffer);\n\n  var canRead = (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) == this.gl.FRAMEBUFFER_COMPLETE);\n  if (canRead) {\n\n    var texture = null;\n\n    for (var i = 0; i < framebuffer.framebufferTexture2DCalls.length; i++) {\n      var args = framebuffer.framebufferTexture2DCalls[i];\n      if (args[3]) {\n        texture = args[3];\n      }\n    }\n\n    if (texture != null) {\n      var size = helpers.getTextureSize(texture);\n      var pixels = new Uint8Array(size.width * size.height * 4);\n      this.gl.readPixels(0, 0, size.width, size.height, this.gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = size.width;\n      canvas.height = size.height;\n\n      var context = canvas.getContext(\"2d\");\n      var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n      imageData.data.set(pixels);\n      context.putImageData(imageData, 0, 0);\n\n      data = {\n        \"url\" : canvas.toDataURL(),\n        \"width\": size.width,\n        \"height\": size.height,\n      };\n    }\n  }\n\n  this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, boundFramebuffer);\n\n  return data;\n}\n\nglpBufferViewer.prototype.getFrameBuffer = function(index) {\n  if (index < 0 || index >= this.buffers.length) {\n    return;\n  }\n\n  var buffer = this.framebuffers[index];\n  var base64Url = this.createBase64Url(buffer);\n\n  var source = {};\n  source.imgSrc = base64Url.url;\n  source.width = base64Url.width;\n  source.height = base64Url.height;\n  source.deleted = buffer.deleted;\n\n  this.gl.glp().messages.sendMessage(messageType.GET_BUFFER, JSON.stringify({\n    \"index\" : index,\n    \"source\" : source,\n    \"framebufferRenderbufferCalls\" : helpers.getGLArgsList(this.gl, buffer.framebufferRenderbufferCalls),\n    \"framebufferTexture2DCalls\" : helpers.getGLArgsList(this.gl, buffer.framebufferTexture2DCalls),\n  }));\n}\n\nglpBufferViewer.prototype.getRenderBufferStatus = function(renderbuffer) {\n\n  var renderbufferStatus = [\n    this.gl.RENDERBUFFER_WIDTH,\n    this.gl.RENDERBUFFER_HEIGHT,\n    this.gl.RENDERBUFFER_INTERNAL_FORMAT,\n    this.gl.RENDERBUFFER_GREEN_SIZE,\n    this.gl.RENDERBUFFER_BLUE_SIZE,\n    this.gl.RENDERBUFFER_RED_SIZE,\n    this.gl.RENDERBUFFER_ALPHA_SIZE,\n    this.gl.RENDERBUFFER_DEPTH_SIZE,\n    this.gl.RENDERBUFFER_STENCIL_SIZE\n  ];\n\n  var boundRenderbuffer = this.boundRenderbuffer;\n  this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, renderbuffer);\n\n  var statuses = [];\n  for (var i = 0; i < renderbufferStatus.length; i++) {\n    var statusName = helpers.getGLEnumName(this.gl, renderbufferStatus[i]);\n    var parameter = this.gl.getRenderbufferParameter(this.gl.RENDERBUFFER, renderbufferStatus[i]);\n\n    var status = {};\n    status[statusName] = parameter;\n    statuses.push(status);\n  }\n\n  this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, boundRenderbuffer);\n\n  return statuses;\n}\n\nglpBufferViewer.prototype.getRenderBuffer = function(index) {\n  if (index < 0 || index >= this.buffers.length) {\n    return;\n  }\n\n  var buffer = this.renderbuffers[index];\n\n  this.gl.glp().messages.sendMessage(messageType.GET_BUFFER, JSON.stringify({\n    \"index\" : index,\n    \"deleted\" : buffer.deleted,\n    \"renderbufferStatus\" : this.getRenderBufferStatus(buffer),\n    \"framebufferRenderbufferCalls\" : helpers.getGLArgsList(this.gl, buffer.framebufferRenderbufferCalls),\n  }));\n}\n\nglpBufferViewer.prototype.pushBuffer = function(buffer) {\n  this.buffers.push(buffer);\n  buffer.deleted = false;\n  return buffer;\n}\n\nglpBufferViewer.prototype.pushFrameBuffer = function(buffer) {\n  this.framebuffers.push(buffer);\n  buffer.deleted = false;\n  return buffer;\n}\n\nglpBufferViewer.prototype.pushRenderBuffer = function(buffer) {\n  this.renderbuffers.push(buffer);\n  buffer.deleted = false;\n  return buffer;\n}\nvar glpFrameControl = function (gl, window) {\n    this.gl = gl;\n\n    var paused = false;\n\n    var requestFrameCall = {};\n    requestFrameCall.context = null;\n    requestFrameCall.arguments = null;\n    requestFrameCall.timerId = null;\n\n    var intervalCall = {};\n    intervalCall.context = null;\n    intervalCall.timerId = null;\n    intervalCall.arguments = null;\n\n    var timeoutCall = {};\n    timeoutCall.context = null;\n    timeoutCall.timerId = null;\n    timeoutCall.arguments = null;\n\n    var setCall = function(call, original, context, arguments) {\n        call.context = context;\n        call.arguments = arguments;\n        call.timerId = original.apply(context, arguments);\n        return call.timerId;\n    }\n\n    var setFrameCall = function(original, context, arguments) {\n        if (paused) {\n            return -1;\n        }\n\n        requestFrameCall.context = context;\n        requestFrameCall.arguments = arguments;\n\n        requestFrameCall.timerId = original.apply(context, arguments);\n        return requestFrameCall.timerId;\n    }\n\n    var cancelFrameCall = function(original, context, arguments) {\n        if (arguments[0] == -1) {\n            return;\n        }\n        return original.apply(context, arguments);\n    }\n\n    var nextCall = function(call, originalSet, originalClear) {\n        call.timerId = originalSet.call(call.context, function() {\n            call.arguments[0]();\n            originalClear.call(call.context, call.timerId);\n        }, call.arguments[1]);\n    }\n\n    var requestAnimationFrameCall = window.requestAnimationFrame;\n    var cancelAnimationFrameCall = window.cancelAnimationFrame;\n    var setIntervalCall = window.setInterval;\n    var clearIntervalCall = window.clearInterval;\n    var setTimeoutCall = window.setTimeout;\n    var clearTimeoutCall = window.clearTimeout;\n\n    window.setInterval = function() {\n        return setCall(intervalCall, setIntervalCall, this, arguments);\n    }\n\n    window.setTimeout = function() {\n        return setCall(timeoutCall, setTimeoutCall, this, arguments);\n    }\n\n    window.requestAnimationFrame = function() {\n        return setFrameCall(requestAnimationFrameCall, this, arguments);\n    }\n\n    window.cancelAnimationFrame = function() {\n        return cancelFrameCall(cancelAnimationFrameCall, this, arguments);\n    }\n\n    this.play = function() {\n        if (paused) {\n            paused = false;\n\n            if (requestFrameCall.arguments) {\n                setFrameCall(requestAnimationFrameCall, requestFrameCall.context, requestFrameCall.arguments);\n            }\n\n            if (intervalCall.arguments) {\n                setCall(intervalCall, setIntervalCall, intervalCall.context, intervalCall.arguments);\n            }\n\n            if (timeoutCall.arguments) {\n                setCall(timeoutCall, setTimeoutCall, timeoutCall.context, timeoutCall.arguments);\n            }\n        }\n    }\n\n    this.pause = function() {\n        if (!paused) {\n            paused = true;\n\n            if (requestFrameCall.timerId) {\n                cancelAnimationFrameCall.call(requestFrameCall.context, requestFrameCall.timerId);\n            }\n\n            if (intervalCall.timerId) {\n                clearIntervalCall.call(intervalCall.context, intervalCall.timerId);\n            }\n\n            if (timeoutCall.timerId) {\n                clearTimeoutCall.call(timeoutCall.context, timeoutCall.timerId);\n            }\n        }\n    };\n\n    this.nextFrame = function() {\n        if (paused) {\n            if (requestFrameCall.arguments) {\n                requestAnimationFrameCall.apply(requestFrameCall.context, requestFrameCall.arguments);\n            }\n\n            if (intervalCall.arguments) {\n                nextCall(intervalCall, setIntervalCall, clearIntervalCall);\n            }\n\n            if (timeoutCall.arguments) {\n                nextCall(timeoutCall, setTimeoutCall, clearTimeoutCall);\n            }\n        }\n    }\n}\nvar glpProgramUsageCounter = function (gl) {\n  this.gl = gl;\n\n  this.enabled = false;\n  this.usages = {}; \/\/ program.__uuid : usage\n  this.idToProgram = {} \/\/program.__uuid : program\n}\n\nglpProgramUsageCounter.prototype.toggle = function(enabled) {\n  if (enabled) {\n    this.enabled = true;\n  } else {\n    this.enabled = false;\n  }\n}\n\nglpProgramUsageCounter.prototype.reset = function() {\n  this.usages = {};\n}\n\nglpProgramUsageCounter.prototype.addUsage = function(program) {\n  if (this.enabled) {\n    if (this.usages[program.__uuid] != undefined) {\n      this.usages[program.__uuid] += 1;\n    } else {\n      this.usages[program.__uuid] = 1;\n      this.idToProgram[program.__uuid] = program;\n    }\n  }\n}\n\nglpProgramUsageCounter.prototype.getProgram = function(prgoramUUid) {\n  return this.idToProgram[prgoramUUid];\n}\nvar glpDuplicateProgramDetection = function (gl) {\n  this.gl = gl;\n\n  this.enabled = false;\n  this.duplicates = []; \/\/ list of { repeatedProgram : lineNumber }\n  this.duplicatePrograms = {};\n}\n\n\/**\n * Toggles duplicate program usage detection\n *\/\nglpDuplicateProgramDetection.prototype.toggle = function(enable) {\n  this.enabled = enable;\n}\n\nglpDuplicateProgramDetection.prototype.reset = function() {\n  this.duplicates = []\n  this.duplicatePrograms = {};\n}\n\nglpDuplicateProgramDetection.prototype.useProgramCalled = function(program) {\n  if (!this.enabled) {\n    return\n  }\n  var currentProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n\n  if(currentProgram != undefined &&\n     currentProgram.__uuid != undefined &&\n     currentProgram.__uuid == program.__uuid) {\n    \/*\n     * callStack gets the current call stack information up to this point\n     *\/\n    var callStack = this.gl.glp().callStack.helper.getStack();\n    var userStack = this.gl.glp().callStack.helper.getFirstUserStack(callStack);\n    var lineNumber = \"\"\n    var functionName = \"\";\n    if (userStack != null) {\n      lineNumber = userStack.getLineNumber();\n      \/\/ Sometimes the function name can be undefined if\n      \/\/ it\'s called from a global scope or from an object\n      if (userStack.getFunctionName() != undefined) {\n        functionName = userStack.getFunctionName()\n      }\n\n      fileName = userStack.getFileName();\n    }\n\n    var programObj = {\"programId\" : program.__uuid,\n                      \"lineNumber\" : lineNumber,\n                      \"functionName\" : functionName,\n                      \"fileName\" : fileName};\n\n    if (this.duplicatePrograms[programObj] == undefined) {\n      this.duplicates.push(programObj);\n      this.duplicatePrograms[programObj] = true;\n    }\n  }\n}\nvar glpPixelInspector = function (gl) {\n  this.gl = gl;\n\n  this.blendProp = null;\n  this.blendFuncSFactor = null;\n  this.blendFuncDFactor = null;\n  this.depthTest = null;\n  this.clearColor = null;\n  this.vertexShaders = {};\n  this.fragmentShaders = {};\n  this.programs = [];\n  this.programsMap = {};\n  this.programUniformLocations = {};\n  this.originalPrograms = {};\n  this.locationMap = {};\n  this.enabled = false;\n}\n\n\/**\n * Applies uniform to WebGL context\n *\/\nglpPixelInspector.prototype.applyUniform = function (uniform) {\n  var loc = uniform.loc;\n  var type = uniform.type;\n  var value = uniform.value;\n  if (type == this.gl.FLOAT) {\n    this.gl.uniform1f(loc, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_VEC2) {\n    this.gl.uniform2fv(loc, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_VEC3) {\n    this.gl.uniform3fv(loc, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_VEC4) {\n    this.gl.uniform4fv(loc, value);\n    return;\n  }\n  if (type == this.gl.INT) {\n    this.gl.uniform1i(loc, value);\n    return;\n  }\n  if (type == this.gl.INT_VEC2) {\n    this.gl.uniform2iv(loc, value);\n    return;\n  }\n  if (type == this.gl.INT_VEC3) {\n    this.gl.uniform3iv(loc, value);\n    return;\n  }\n  if (type == this.gl.INT_VEC4) {\n    this.gl.uniform4iv(loc, value);\n    return;\n  }\n  if (type == this.gl.BOOL) {\n    this.gl.uniform1i(loc, value);\n    return;\n  }\n  if (type == this.gl.BOOL_VEC2) {\n    this.gl.uniform2iv(loc, value);\n    return;\n  }\n  if (type == this.gl.BOOL_VEC3) {\n    this.gl.uniform3iv(loc, value);\n    return;\n  }\n  if (type == this.gl.BOOL_VEC4) {\n    this.gl.uniform4iv(loc, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_MAT2) {\n    this.gl.uniformMatrix2fv(loc, false, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_MAT3) {\n    this.gl.uniformMatrix3fv(loc, false, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_MAT4) {\n    this.gl.uniformMatrix4fv(loc, false, value);\n    return;\n  }\n  if (type == this.gl.SAMPLER_2D || type == this.gl.SAMPLER_CUBE) {\n    this.gl.uniform1i(loc, value);\n    return;\n  }\n}\n\n\/**\n * Enables the pixel inspector and returns the appropriate fragment shader\n * @return {WebGLShader} Pixel Inspector Shader\n *\/\nglpPixelInspector.prototype.enable = function() {\n    this.blendProp = this.gl.getParameter(this.gl.BLEND);\n    this.gl.enable(this.gl.BLEND);\n\n    this.blendFuncSFactor = this.gl.getParameter(this.gl.BLEND_SRC_RGB);\n    this.blendFuncDFactor = this.gl.getParameter(this.gl.BLEND_DST_RGB);\n    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n\n    this.depthTest = this.gl.getParameter(this.gl.DEPTH_TEST);\n    this.gl.disable(this.gl.DEPTH_TEST);\n\n    this.clearColor = this.gl.getParameter(this.gl.COLOR_CLEAR_VALUE);\n    this.gl.clearColor(0.0, 1.0, 0.0, 1.0);\n\n    this.switchToProgram();\n\n    this.enabled = true;\n}\n\n\/**\n * Disable the pixel inspector and returns the appropriate fragment shader\n * @return {WebGLShader} Pixel Inspector Shader\n *\/\nglpPixelInspector.prototype.disable = function() {\n    if (!this.enabled) {\n      return;\n    }\n    this.enabled = false;\n\n    if (!this.blendProp) {\n      this.gl.disable(this.gl.BLEND);\n    } else {\n      if (this.blendFuncSFactor && this.blendFuncDFactor) {\n        this.gl.blendFunc(this.blendFuncSFactor, this.blendFuncDFactor);\n      }\n    }\n\n    if (this.depthTest) {\n      this.gl.enable(this.gl.DEPTH_TEST);\n    }\n\n    if (this.clearColor) {\n      this.gl.clearColor.apply(this.gl, this.clearColor);\n    }\n\n    var currentProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n    if (currentProgram.__uuid in this.originalPrograms) {\n      var newProgram = this.originalPrograms[currentProgram.__uuid];\n      this.gl.useProgram(newProgram);\n      this.copyUniforms(currentProgram, newProgram);\n    }\n}\n\n\/**\n * Copies uniforms from oldProgram to newProgram\n *\/\nglpPixelInspector.prototype.copyUniforms = function(oldProgram, program) {\n  var activeUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);\n  this.locationMap[program.__uuid] = {};\n\n  for (var i=0; i < activeUniforms; i++) {\n      var uniform = this.gl.getActiveUniform(program, i);\n      var oldLocation = this.gl.getUniformLocation(oldProgram, uniform.name);\n      var newLocation = this.gl.getUniformLocation(program, uniform.name);\n      if (!oldLocation) {\n        continue;\n      }\n      this.locationMap[program.__uuid][oldLocation.__uuid] = newLocation;\n\n      uniform.loc = newLocation;\n      uniform.value = this.gl.getUniform(oldProgram, oldLocation);\n      if (uniform.value != null) {\n        this.applyUniform(uniform);\n      }\n  }\n}\n\n\/**\n * Copies attributes from oldProgram to newProgram\n *\/\nglpPixelInspector.prototype.copyAttributes = function(oldProgram, program) {\n  var activeAttributes = this.gl.getProgramParameter(oldProgram, this.gl.ACTIVE_ATTRIBUTES);\n\n  for (var i=0; i < activeAttributes; i++) {\n      var attribute = this.gl.getActiveAttrib(oldProgram, i);\n\n      this.gl.bindAttribLocation(program, attribute.index, attribute.name);\n      if (attribute.size > 1) {\n        this.gl.vertexAttribPointer(\n          attribute.index,\n          attribute.size,\n          attribute.type,\n          attribute.normalized,\n          attribute.stride,\n          attribute.offset\n        );\n      }\n\n      this.gl.enableVertexAttribArray(attribute.index);\n  }\n}\n\n\/**\n * Switches the current program to the pixel inspector program\n *\/\nglpPixelInspector.prototype.switchToProgram = function() {\n  var oldProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n  var program = this.getProgram(oldProgram);\n  this.originalPrograms[program.__uuid] = oldProgram;\n  this.switchProgram(oldProgram, program);\n}\n\n\/**\n * Switches the current program and copies over location and attribute data\n *\/\nglpPixelInspector.prototype.switchProgram = function(oldProgram, program) {\n  if (!this.enabled) {\n    return;\n  }\n  this.gl.useProgram(program);\n  this.copyUniforms(oldProgram, program);\n  this.copyAttributes(oldProgram, program);\n}\n\nglpPixelInspector.prototype.hasProgram = function(program) {\n  return this.programs.indexOf(program.__uuid) >= 0;\n}\n\n\/**\n * Returns the pixel inspector fragment shader\n * @return {WebGLShader} Pixel Inspector Fragment Shader\n *\/\nglpPixelInspector.prototype.getFragShader = function() {\n    var fragShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n    var shaderStr = \'precision mediump float;\' +\n        \'void main(void) {\' +\n            \'gl_FragColor = vec4(1.0, 0.0, 0.0, 0.10);\' +\n        \'}\';\n\n    this.gl.shaderSource(fragShader, shaderStr);\n    this.gl.compileShader(fragShader);\n\n    return fragShader;\n}\n\n\/**\n * Returns the appropriate pixel inspector program\n * @param {WebGLProgram} Original Program\n * @return {WebGLProgram.__uuid} Pixel Inspector Progam\n *\/\nglpPixelInspector.prototype.getProgram = function(originalProgram) {\n    if (originalProgram.__uuid in this.programsMap) {\n        return this.programsMap[originalProgram.__uuid];\n    }\n\n    var program = this.gl.createProgram();\n\n    this.gl.attachShader(program, this.vertexShaders[originalProgram.__uuid]);\n    this.gl.attachShader(program, this.getFragShader());\n    this.gl.linkProgram(program);\n    this.gl.validateProgram(program);\n\n    this.programs.push(program.__uuid);\n    this.programsMap[originalProgram.__uuid] = program;\n\n    return program;\n}\n\nglpPixelInspector.prototype.storeShaders = function(program, shader) {\n  var shaderType = this.gl.getShaderParameter(shader, this.gl.SHADER_TYPE);\n\n  \/\/ TODO: verify valid input\n  \/\/ store vertex shaders associated with program\n  if (shaderType == this.gl.VERTEX_SHADER) {\n    this.vertexShaders[program.__uuid] = shader;\n  } else {\n    this.fragmentShaders[program.__uuid] = shader;\n  }\n}\n\nglpPixelInspector.prototype.saveStates = function(arg, truth) {\n  if (this.enabled) {\n    if (arg == this.gl.DEPTH_TEST) {\n      this.depthTest = truth;\n      return true;\n    } else if (arg == this.gl.BLEND) {\n      this.blendProp = truth;\n      return true;\n    }\n  }\n  return this.enabled;\n}\n\nglpPixelInspector.prototype.storeBlendStates = function(sFactor, dFactor) {\n  if (this.enabled) {\n    this.blendFuncSFactor = sFactor;\n    this.blendFuncDFactor = dFactor;\n  }\n  return this.enabled;\n}\n\nglpPixelInspector.prototype.storeClearColorStates = function(args) {\n  \/\/ TODO: verify valid input\n  if (this.enabled) {\n    this.clearColor = args;\n  }\n  return this.enabled;\n}\n\nglpPixelInspector.prototype.uniforms = function(args) {\n  if (this.enabled) {\n    var program = args[0];\n    var location = args[1];\n    if (this.programs.indexOf(program.__uuid) >= 0) {\n      if (location in this.locationMap[program.__uuid]) {\n        \/\/ the program is the pixel inspector version and we\'re using the original location\n        args[1] = this.locationMap[program.__uuid][location.__uuid];\n      } else {\n      }\n    } else {\n      \/\/ the program is not a pixel inspector\n      \/\/ if they\'re using the wrong location, lets just swap programs\n      args[0] = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n    }\n  }\n  return args;\n}\n\nglpPixelInspector.prototype.hasUniformLocation = function(program, name) {\n  if (!(program.__uuid in this.programUniformLocations)) {\n    this.programUniformLocations[program.__uuid] = {}\n  }\n  return (name in this.programUniformLocations[program.__uuid]);\n}\n\nglpPixelInspector.prototype.getUniformLocation = function(program, name) {\n  if (!(program.__uuid in this.programUniformLocations)) {\n    this.programUniformLocations[program.__uuid] = {}\n  }\n  return this.programUniformLocations[program.__uuid][name];\n}\n\nglpPixelInspector.prototype.setUniformLocation = function(program, name, location) {\n  location.__uuid = glpHelpers.guid();\n  if (!(program.__uuid in this.programUniformLocations)) {\n    this.programUniformLocations[program.__uuid] = {}\n  }\n  this.programUniformLocations[program.__uuid][name] = location;\n  return location;\n}\n\nglpPixelInspector.prototype.remapLocations = function(args) {\n  if (this.enabled) {\n    if (args[0] &&\n        this.programs.indexOf(this.gl.getParameter(this.gl.CURRENT_PROGRAM).__uuid) >= 0) {\n      args[0] =\n        this.locationMap[this.gl.getParameter(this.gl.CURRENT_PROGRAM).__uuid][args[0].__uuid];\n    }\n  }\n  return args\n}\nvar glpDepthInspector = function (gl) {\n  this.gl = gl;\n\n  this.clearColor = null;\n  this.vertexShaders = {};\n  this.fragmentShaders = {};\n  this.programs = [];\n  this.programsMap = {};\n  this.programUniformLocations = {};\n  this.originalPrograms = {};\n  this.locationMap = {};\n  this.enabled = false;\n  this.framebufferIsBound = false;\n  this.renderbufferIsBound = false;\n  this.farLocation = null;\n  this.nearLocation = null;\n}\n\n\/**\n * Applies uniform to WebGL context\n *\/\nglpDepthInspector.prototype.applyUniform = function (uniform) {\n  var loc = uniform.loc;\n  var type = uniform.type;\n  var value = uniform.value;\n  if (type == this.gl.FLOAT) {\n    this.gl.uniform1f(loc, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_VEC2) {\n    this.gl.uniform2fv(loc, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_VEC3) {\n    this.gl.uniform3fv(loc, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_VEC4) {\n    this.gl.uniform4fv(loc, value);\n    return;\n  }\n  if (type == this.gl.INT) {\n    this.gl.uniform1i(loc, value);\n    return;\n  }\n  if (type == this.gl.INT_VEC2) {\n    this.gl.uniform2iv(loc, value);\n    return;\n  }\n  if (type == this.gl.INT_VEC3) {\n    this.gl.uniform3iv(loc, value);\n    return;\n  }\n  if (type == this.gl.INT_VEC4) {\n    this.gl.uniform4iv(loc, value);\n    return;\n  }\n  if (type == this.gl.BOOL) {\n    this.gl.uniform1i(loc, value);\n    return;\n  }\n  if (type == this.gl.BOOL_VEC2) {\n    this.gl.uniform2iv(loc, value);\n    return;\n  }\n  if (type == this.gl.BOOL_VEC3) {\n    this.gl.uniform3iv(loc, value);\n    return;\n  }\n  if (type == this.gl.BOOL_VEC4) {\n    this.gl.uniform4iv(loc, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_MAT2) {\n    this.gl.uniformMatrix2fv(loc, false, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_MAT3) {\n    this.gl.uniformMatrix3fv(loc, false, value);\n    return;\n  }\n  if (type == this.gl.FLOAT_MAT4) {\n    this.gl.uniformMatrix4fv(loc, false, value);\n    return;\n  }\n  if (type == this.gl.SAMPLER_2D || type == this.gl.SAMPLER_CUBE) {\n    this.gl.uniform1i(loc, value);\n    return;\n  }\n}\n\n\/**\n * Enables the pixel inspector and returns the appropriate fragment shader\n * @return {WebGLShader} Pixel Inspector Shader\n *\/\nglpDepthInspector.prototype.enable = function(near, far) {\n    if (this.framebufferIsBound || this.renderbufferIsBound) {\n      return;\n    }\n    this.near = near;\n    this.far = far;\n    this.clearColor = this.gl.getParameter(this.gl.COLOR_CLEAR_VALUE);\n    this.gl.clearColor(1.0, 1.0, 1.0, 1.0);\n\n    this.switchToProgram();\n\n    this.enabled = true;\n}\n\n\/**\n * Disable the pixel inspector and returns the appropriate fragment shader\n * @return {WebGLShader} Pixel Inspector Shader\n *\/\nglpDepthInspector.prototype.disable = function() {\n    if (!this.enabled) {\n      return;\n    }\n    this.enabled = false;\n\n    if (this.clearColor) {\n      this.gl.clearColor.apply(this.gl, this.clearColor);\n    }\n\n    var currentProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n    if (currentProgram.__uuid in this.originalPrograms) {\n      var newProgram = this.originalPrograms[currentProgram.__uuid];\n      this.gl.useProgram(newProgram);\n      this.copyUniforms(currentProgram, newProgram);\n    }\n}\n\nglpDepthInspector.prototype.bindFrameBuffer = function(enable) {\n  this.framebufferIsBound = !!enable;\n  this.toggleByBuffer(!!enable);\n}\n\nglpDepthInspector.prototype.bindRenderBuffer = function(enable) {\n  this.renderbufferIsBound = !!enable;\n  this.toggleByBuffer(!!enable);\n}\n\nglpDepthInspector.prototype.toggleByBuffer = function(enable) {\n  if (!this.enabled) {\n    return;\n  }\n\n  if (!this.framebufferIsBound && !this.renderbufferIsBound) {\n    this.enable();\n  } else {\n    this.disable();\n  }\n}\n\n\/**\n * Copies uniforms from oldProgram to newProgram\n *\/\nglpDepthInspector.prototype.copyUniforms = function(oldProgram, program) {\n  var activeUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);\n  this.locationMap[program.__uuid] = {};\n\n  for (var i=0; i < activeUniforms; i++) {\n      var uniform = this.gl.getActiveUniform(program, i);\n      var oldLocation = this.gl.getUniformLocation(oldProgram, uniform.name);\n      var newLocation = this.gl.getUniformLocation(program, uniform.name);\n      if (!oldLocation) {\n        continue;\n      }\n      this.locationMap[program.__uuid][oldLocation.__uuid] = newLocation;\n\n      uniform.loc = newLocation;\n      uniform.value = this.gl.getUniform(oldProgram, oldLocation);\n      if (uniform.value != null) {\n        this.applyUniform(uniform);\n      }\n  }\n}\n\n\/**\n * Switches the current program to the pixel inspector program\n *\/\nglpDepthInspector.prototype.switchToProgram = function() {\n  var oldProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n  var program = this.getProgram(oldProgram);\n  this.originalPrograms[program.__uuid] = oldProgram;\n  this.switchProgram(oldProgram, program);\n}\n\n\/**\n * Switches the current program and copies over location and attribute data\n *\/\nglpDepthInspector.prototype.switchProgram = function(oldProgram, program) {\n  if (!this.enabled) {\n    return;\n  }\n  this.gl.useProgram(program);\n  this.copyUniforms(oldProgram, program);\n  this.nearLocation = this.gl.getUniformLocation(program, \"near\");\n  this.farLocation = this.gl.getUniformLocation(program, \"far\");\n  this.gl.uniform1f(this.nearLocation, this.near);\n  this.gl.uniform1f(this.farLocation, this.far);\n}\n\nglpDepthInspector.prototype.hasProgram = function(program) {\n  return this.programs.indexOf(program.__uuid) >= 0;\n}\n\n\/**\n * Returns the pixel inspector fragment shader\n * @return {WebGLShader} Pixel Inspector Fragment Shader\n *\/\nglpDepthInspector.prototype.getFragShader = function() {\n    var fragShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n    var shaderStr = \"precision mediump float;\" +\n                      \"uniform float near;\" +\n                      \"uniform float far;\" +\n                      \"void main(void) {\" +\n                      \" float depth = gl_FragCoord.z \/ gl_FragCoord.w;\" +\n                      \" float color = smoothstep( near, far, depth );\" +\n                      \" gl_FragColor = vec4( vec3(color), 1.0 );\" +\n                    \"}\";\n\n    this.gl.shaderSource(fragShader, shaderStr);\n    this.gl.compileShader(fragShader);\n\n    return fragShader;\n}\n\n\/**\n * Returns the appropriate pixel inspector program\n * @param {WebGLProgram} Original Program\n * @return {WebGLProgram.__uuid} Pixel Inspector Progam\n *\/\nglpDepthInspector.prototype.getProgram = function(originalProgram) {\n    if (originalProgram.__uuid in this.programsMap) {\n        return this.programsMap[originalProgram.__uuid];\n    }\n\n    var program = this.gl.createProgram();\n\n    this.gl.attachShader(program, this.vertexShaders[originalProgram.__uuid]);\n    this.gl.attachShader(program, this.getFragShader());\n    this.gl.linkProgram(program);\n    this.gl.validateProgram(program);\n\n    this.programs.push(program.__uuid);\n    this.programsMap[originalProgram.__uuid] = program;\n\n    return program;\n}\n\nglpDepthInspector.prototype.storeShaders = function(program, shader) {\n  var shaderType = this.gl.getShaderParameter(shader, this.gl.SHADER_TYPE);\n\n  \/\/ TODO: verify valid input\n  \/\/ store vertex shaders associated with program\n  if (shaderType == this.gl.VERTEX_SHADER) {\n    this.vertexShaders[program.__uuid] = shader;\n  } else {\n    this.fragmentShaders[program.__uuid] = shader;\n  }\n}\n\nglpDepthInspector.prototype.storeClearColorStates = function(args) {\n  \/\/ TODO: verify valid input\n  if (this.enabled) {\n    this.clearColor = args;\n  }\n  return this.enabled;\n}\n\nglpDepthInspector.prototype.uniforms = function(args) {\n  if (this.enabled) {\n    var program = args[0];\n    var location = args[1];\n    if (this.programs.indexOf(program.__uuid) >= 0) {\n      if (location in this.locationMap[program.__uuid]) {\n        \/\/ the program is the pixel inspector version and we\'re using the original location\n        args[1] = this.locationMap[program.__uuid][location.__uuid];\n      } else {\n      }\n    } else {\n      \/\/ the program is not a pixel inspector\n      \/\/ if they\'re using the wrong location, lets just swap programs\n      args[0] = this.gl.getParameter(this.gl.CURRENT_PROGRAM);\n    }\n  }\n  return args;\n}\n\nglpDepthInspector.prototype.hasUniformLocation = function(program, name) {\n  if (!(program.__uuid in this.programUniformLocations)) {\n    this.programUniformLocations[program.__uuid] = {}\n  }\n  return (name in this.programUniformLocations[program.__uuid]);\n}\n\nglpDepthInspector.prototype.getUniformLocation = function(program, name) {\n  if (!(program.__uuid in this.programUniformLocations)) {\n    this.programUniformLocations[program.__uuid] = {}\n  }\n  return this.programUniformLocations[program.__uuid][name];\n}\n\nglpDepthInspector.prototype.setUniformLocation = function(program, name, location) {\n  if (!location.__uuid) {\n    location.__uuid = glpHelpers.guid();\n  }\n  if (!(program.__uuid in this.programUniformLocations)) {\n    this.programUniformLocations[program.__uuid] = {}\n  }\n  this.programUniformLocations[program.__uuid][name] = location;\n  return location;\n}\n\nglpDepthInspector.prototype.remapLocations = function(args) {\n  if (this.enabled) {\n    if (args[0] == this.nearLocation || args[0] == this.farLocation) {\n      return args;\n    }\n    if (args[0] &&\n        this.programs.indexOf(this.gl.getParameter(this.gl.CURRENT_PROGRAM).__uuid) >= 0) {\n      args[0] =\n        this.locationMap[this.gl.getParameter(this.gl.CURRENT_PROGRAM).__uuid][args[0].__uuid];\n    }\n  }\n  return args\n}\n\/\/ Only supports gl.TEXTURE_2D at the moment\n\nvar glpMipmapViewer = function(gl) {\n  this.gl = gl;\n\n  this.textureUsage = {}\n  this.activeTexture = null;\n\n  this.mipmapPixels = null;\n  this.currentLevel = 0;\n  this.uuidToTexture = {};\n\n  this.enabled = false;\n  this.currentBoundTexture = null;\n}\n\nglpMipmapViewer.prototype.texImage2DFcnType = {\n  TEX_IMAGE_2D_6 : 0,\n  TEX_IMAGE_2D_9 : 1\n}\n\nglpMipmapViewer.prototype.getMipmapLevelColor = function(level, maxLevel) {\n\n  var ratio = level \/ maxLevel;\n\n  \/\/ Rainbow colors\n  var i = level * 220 \/ maxLevel;\n  var r = Math.round(Math.sin(0.024 * i + 0) * 127 + 128);\n  var g = Math.round(Math.sin(0.024 * i + 2) * 127 + 128);\n  var b = Math.round(Math.sin(0.024 * i + 4) * 127 + 128);\n\n  return [r * 255,\n        g * 255,\n        b * 255,\n        255]\n\n}\n\nglpMipmapViewer.prototype.generateColorImage = function(width, height, level, maxLevel) {\n  \/* width and height are orders of 2\n\n  internalFormat can be the following parameters:\n  gl.ALPHA, gl.LUMINANCE, gl.LUMINANCE_ALPHAA, gl.RGB, gl.RGBA\n\n  type can be the following parameters:\n  gl.UNSIGNED_BYTE, gl.FLOAT, gl.UNSIGNED_SHORT_5_6_5,\n  gl.UNSIGNED_SHORT_4_4_4_4, gl.UNSIGNED_SHORT_5_5_5_1\n\n  more information can be found at:\n  https:\/\/msdn.microsoft.com\/en-us\/library\/dn302435(v=vs.85).aspx *\/\n\n  \/\/ Computing the number of components\n\n  numComponentsPerPixel = 4\n  var numPixels = width * height;\n  var pixels = new Uint8Array(numPixels * numComponentsPerPixel);\n  var color = this.getMipmapLevelColor(level, maxLevel);\n\n  for (var i = 0; i < numPixels; i++) {\n    for( var c = 0; c < numComponentsPerPixel; c++) {\n      pixels[i*numComponentsPerPixel+c] = color[c];\n    }\n  }\n  return pixels;\n\n  return null;\n\n}\n\nglpMipmapViewer.prototype.getTextureList = function() {\n  textures = [];\n  var i = 0;\n  for (key in this.textureUsage) {\n    var active = this.activeTexture ? (key == this.activeTexture.__uuid) : false\n    textures.push({\n      name: \"Texture\" + i,\n      uuid: key,\n      active: active,\n    });\n    i++;\n  }\n  return textures;\n}\n\nglpMipmapViewer.prototype.enable = function(textureKey) {\n  if (this.enabled) {\n    this.disable();\n  } else {\n    this.currentBoundTexture = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n  }\n  var texture = textureKey ? this.uuidToTexture[textureKey] : this.activeTexture;\n  this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n  console.log()\n  this.enabled = true;\n  this.enableMipmapView(texture);\n}\n\nglpMipmapViewer.prototype.disable = function() {\n  if (!this.enabled) {\n    return;\n  }\n  this.disableMipmapView(this.activeTexture);\n  this.enabled = false;\n}\n\nglpMipmapViewer.prototype.enableMipmapView = function(textureKey) {\n  var textureObj = this.textureUsage[textureKey.__uuid];\n  if (!textureObj) return;\n  if (!textureObj.imageLevels[0]) return;\n\n  var imageLvl0 = textureObj.imageLevels[0];\n\n  this.currentBoundTexture = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n\n  this.gl.bindTexture(this.gl.TEXTURE_2D, textureKey);\n  var textureInfo = this.getTextureMipmapInfo(imageLvl0);\n  this.gl.bindTexture(this.gl.TEXTURE_2D, this.activeTexture);\n  var dim = textureObj.generateMipmap ?\n            textureInfo.size.width : Math.pow(2, textureObj.imageLevels.length - 1)\n\n  var maxTextureSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);\n  var maxMipmapLevel = Math.log2(maxTextureSize);\n\n  var mipmapPixels = this.generateColorImage(dim, dim, 0, maxMipmapLevel);\n  var level = 0;\n  var width = dim;\n  var height = dim;\n  while (width >= 1 && height >= 1) {\n    this.mipmapPixels = this.generateColorImage(width, height, level, maxMipmapLevel);\n    this.currentLevel = level;\n    this.gl.texImage2D(\n      this.gl.TEXTURE_2D,\n      level,\n      this.gl.RGBA,\n      width,\n      height,\n      0,\n      this.gl.RGBA,\n      this.gl.UNSIGNED_BYTE,\n      this.mipmapPixels);\n    width \/= 2;\n    height \/= 2;\n    level += 1;\n  }\n\n  this.gl.bindTexture(this.gl.TEXTURE_2D, this.currentBoundTexture);\n}\n\nglpMipmapViewer.prototype.getTextureSize = function(textureObjLevel) {\n  var size = { width : 0, height : 0};\n  if (textureObjLevel.functionType == this.texImage2DFcnType.TEX_IMAGE_2D_6){\n    var img = textureObjLevel.arguments[5]\n    size.width = img.width;\n    size.height = img.height;\n  } else {\n    size.width = textureObjLevel.arguments[3];\n    size.height = textureObjLevel.arguments[4];\n  }\n\n  return size;\n}\n\nglpMipmapViewer.prototype.getTextureMipmapInfo = function(textureObjLevel) {\n  var info = { size : { width: 0, height : 0 },\n         internalFormat : undefined,\n         format : undefined,\n         type : undefined };\n\n  if (textureObjLevel.functionType == this.texImage2DFcnType.TEX_IMAGE_2D_6){\n    var img = textureObjLevel.arguments[5]\n    info.size.width = img.width;\n    info.size.height = img.height;\n    info.internalFormat = textureObjLevel.arguments[2];\n    info.format = textureObjLevel.arguments[3];\n    info.type = textureObjLevel.arguments[4];\n  } else {\n    info.size.width = textureObjLevel.arguments[3];\n    info.size.height = textureObjLevel.arguments[4];\n    info.internalFormat = textureObjLevel.arguments[2];\n    info.format = textureObjLevel.arguments[6]\n    info.type = textureObjLevel.arguments[7]\n  }\n\n  return info;\n}\n\nglpMipmapViewer.prototype.disableMipmapView = function(textureKey) {\n  var textureObj = this.textureUsage[textureKey.__uuid];\n  if (!textureObj) return;\n  if (!textureObj.imageLevels[0]) return;\n\n  var textureObj = this.textureUsage[textureKey.__uuid];\n\n  var currentBoundTexture = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n\n  this.gl.bindTexture(this.gl.TEXTURE_2D, textureKey);\n\n  for(var i = 0; i < textureObj.fcnUsages.length; i++) {\n    var fcnUsage = textureObj.fcnUsages[i];\n    fcnUsage.fcn.apply(this.gl, fcnUsage.args);\n  }\n\n\n  this.gl.bindTexture(this.gl.TEXTURE_2D, currentBoundTexture);\n\n}\n\nglpMipmapViewer.prototype.pushTextureKey = function(textureKey) {\n  if (!textureKey.__uuid) {\n    textureKey.__uuid = glpHelpers.guid();\n  }\n  if (this.textureUsage[textureKey.__uuid] != undefined) {\n    return;\n  }\n  this.uuidToTexture[textureKey.__uuid] = textureKey;\n  this.textureUsage[textureKey.__uuid] = { generateMipmap : false,\n                    imageLevels : [],\n                    fcnUsages : [] };\n}\n\nglpMipmapViewer.prototype.updateActiveTexture = function(activeTexture) {\n  if (!this.enabled){\n    this.activeTexture = activeTexture;\n  }\n}\n\nglpMipmapViewer.prototype.textureExists = function(textureKey) {\n  return (textureKey != null &&\n      this.textureUsage[textureKey.__uuid] != undefined);\n}\n\nglpMipmapViewer.prototype.texImage2D = function(original, args) {\n  if (!this.textureExists(this.activeTexture)) {\n    return;\n  }\n\n  if(args.length == 9 && args[8] == this.mipmapPixels && args[1] == this.currentLevel) {\n    return;\n  }\n  \/\/ figure out which function type it\'s using\n  var textureObj = this.textureUsage[this.activeTexture.__uuid];\n  var level = args[1];\n  if (args.length == 6) {\n    textureObj.imageLevels.splice(level, 0, {\n      functionType : this.texImage2DFcnType.TEX_IMAGE_2D_6,\n      arguments : args });\n  } else if (args.length == 9) {\n    textureObj.imageLevels.splice(level, 0, {\n      functionType : this.texImage2DFcnType.TEX_IMAGE_2D_9,\n      arguments : args });\n  } else {\n    console.error(\"texImage2D function args is not valid\");\n    return;\n  }\n\n  textureObj.fcnUsages.push( { fcn : original, args: args } );\n}\n\nglpMipmapViewer.prototype.texSubImage2D = function(original, args) {\n  if (!this.textureExists(this.activeTexture)) {\n    return;\n  }\n\n  \/\/ figure out which function type it\'s using\n  var textureObj = this.textureUsage[this.activeTexture.__uuid];\n  var level = args[1];\n  if (args.length == 7) {\n    textureObj.imageLevels.splice(level, 1, {\n      functionType : this.texImage2DFcnType.TEX_IMAGE_2D_6,\n      arguments : args });\n  } else if (args.length == 9) {\n    textureObj.imageLevels.splice(level, 1, {\n      functionType : this.texImage2DFcnType.TEX_IMAGE_2D_9,\n      arguments : args });\n  } else {\n    console.error(\"texSubImage2D function args is not valid\");\n    return;\n  }\n\n  textureObj.fcnUsages.push( { fcn : original, args: args } );\n}\n\nglpMipmapViewer.prototype.generateMipmap = function(original, args) {\n  if (!this.textureExists(this.activeTexture)) {\n    return;\n  }\n\n  var textureObj = this.textureUsage[this.activeTexture.__uuid];\n  textureObj.generateMipmap = true;\n  textureObj.fcnUsages.push( { fcn : original, args: args })\n}\n\nglpMipmapViewer.prototype.storeFunctions = function(original, args) {\n  if (!this.textureExists(this.activeTexture)) {\n    return;\n  }\n\n  var textureObj = this.textureUsage[this.activeTexture.__uuid];\n  textureObj.fcnUsages.push( { fcn : original, args: args })\n}\n\nvar glpTextureViewer = function (gl) {\n    this.gl = gl;\n\n    this.textures = [];\n    this.boundTexture = null;\n}\n\n\/**\n * Sends the number of textures created to the front end\n **\/\nglpTextureViewer.prototype.getTextures = function() {\n    this.gl.glp().messages.sendMessage(messageType.GET_TEXTURES, { \"length\" : this.textures.length });\n}\n\nglpTextureViewer.prototype.bindTexture = function(bindingPoint, texture) {\n    if (this.boundTexture != null && this.boundTexture != texture) {\n        this.boundTexture.bindingPoint = bindingPoint;\n        this.boundTexture.rendered = false;\n    }\n    this.boundTexture = texture;\n}\n\nglpTextureViewer.prototype.unbindTexture = function() {\n    if (this.boundTexture != null) {\n        this.boundTexture.rendered = false;\n    }\n    this.boundTexture = null;\n}\n\nglpTextureViewer.prototype.addCall = function(callList, args) {\n    if (args) {\n        callList.push(Array.prototype.slice.call(args));\n    }\n}\n\nglpTextureViewer.prototype.texImage2D = function(args) {\n    if (this.boundTexture != null && !this.boundTexture.rendered) {\n        if (!this.boundTexture.texImage2DCalls) {\n            this.boundTexture.texImage2DCalls = [];\n        }\n        this.addCall(this.boundTexture.texImage2DCalls, args);\n    }\n}\n\nglpTextureViewer.prototype.texSubImage2D = function(args) {\n    if (this.boundTexture != null && !this.boundTexture.rendered) {\n        if (!this.boundTexture.texSubImage2DCalls) {\n            this.boundTexture.texSubImage2DCalls = [];\n        }\n        this.addCall(this.boundTexture.texSubImage2DCalls, args);\n    }\n}\n\nglpTextureViewer.prototype.texParameteri = function(args) {\n    if (this.boundTexture != null && !this.boundTexture.rendered) {\n        if (!this.boundTexture.texParameteriCalls) {\n            this.boundTexture.texParameteriCalls = [];\n        }\n        this.addCall(this.boundTexture.texParameteriCalls, args);\n    }\n}\n\nglpTextureViewer.prototype.texParameterf = function(args) {\n    if (this.boundTexture != null && !this.boundTexture.rendered) {\n        if (!this.boundTexture.texParameterfCalls) {\n            this.boundTexture.texParameterfCalls = [];\n        }\n        this.addCall(this.boundTexture.texParameterfCalls, args);\n    }\n}\n\nglpTextureViewer.prototype.createBase64Url = function(gl, texture) {\n    var frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n    var data = null;\n\n    var canRead = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);\n    if (canRead) {\n        var size = helpers.getTextureSize(texture);\n        var pixels = new Uint8Array(size.width * size.height * 4);\n        gl.readPixels(0, 0, size.width, size.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n        var canvas = document.createElement(\"canvas\");\n        canvas.width = size.width;\n        canvas.height = size.height;\n\n        var context = canvas.getContext(\"2d\");\n        var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n        imageData.data.set(pixels);\n        context.putImageData(imageData, 0, 0);\n\n        data = {\n            \"url\" : canvas.toDataURL(),\n            \"width\": size.width,\n            \"height\": size.height,\n        };\n    }\n\n    gl.deleteFramebuffer(frameBuffer);\n\n    return data;\n}\n\nglpTextureViewer.prototype.getTextureSource = function(texture) {\n\n    var data = {};\n    data.width = 16;\n    data.height = 16;\n\n    if (texture.texImage2DCalls) {\n        for (var i = 0; i < texture.texImage2DCalls.length; i++) {\n            var args = texture.texImage2DCalls[i];\n            if (args[1] == 0) {\n                if (args.length == 9 && args[8]) {\n                    data.width = Math.max(args[3], data.width);\n                    data.height = Math.max(args[4], data.height);\n                    data.arraySrc = Array.prototype.slice.call(args[8]);\n                } else if (args[5]) {\n                    var pixels = args[5];\n\n                    data.width = Math.max(pixels.width, data.width);\n                    data.height = Math.max(pixels.height, data.height);\n                    if (pixels instanceof HTMLImageElement) {\n                        data.imgSrc = pixels.src;\n                    } else if (pixels instanceof HTMLCanvasElement) {\n                        data.imgSrc = pixels.toDataURL();\n                    } else if (pixels instanceof HTMLVideoElement) {\n                        data.videoSrc = pixels.src;\n                    } else if (pixels instanceof ImageData) {\n                        data.arraySrc = Array.prototype.slice.call(pixels.data);\n                    }\n                }\n            }\n        }\n    }\n\n    return data;\n}\n\n\/**\n * Get a texture in the textures list by its index.\n * Sends the texture to the front end\n **\/\nglpTextureViewer.prototype.getTexture = function(index) {\n    if (index < 0 || index >= this.textures.length) {\n        return;\n    }\n\n    var texture = this.textures[index];\n    var source = this.getTextureSource(texture);\n\n    if (source.arraySrc) {\n        var base64Url = this.createBase64Url(this.gl, texture);\n        if (base64Url != null) {\n            source.imgSrc = base64Url.url;\n            source.width = base64Url.width;\n            source.height = base64Url.height;\n        }\n    }\n\n    var textureInformation = {\n        \"index\": index,\n        \"source\": source,\n        \"texImage2DCalls\": helpers.getGLArgsList(this.gl, texture.texImage2DCalls),\n        \"texSubImage2DCalls\": helpers.getGLArgsList(this.gl, texture.texSubImage2DCalls),\n        \"texParameteriCalls\": helpers.getGLArgsList(this.gl, texture.texParameteriCalls),\n        \"texParameterfCalls\": helpers.getGLArgsList(this.gl, texture.texParameterfCalls),\n    };\n\n    this.gl.glp().messages.sendMessage(messageType.GET_TEXTURE, JSON.stringify(textureInformation));\n}\n\nglpTextureViewer.prototype.pushTexture = function(texture) {\n    this.textures.push(texture);\n    return texture;\n}\nvar glpContexts = (function () {\n\ncontexts = {};\n\n\/**\n * Returns the WebGL contexts available in the dom\n * @param {Array} WebGL Contexts\n *\/\ncontexts.getWebGLContexts = function() {\n  var canvases = document.getElementsByTagName(\"canvas\");\n  var c = [];\n  var counter = 0;\n  for (var i = 0; i < canvases.length; i++) {\n    var canvas = canvases[i];\n    var webGLContext = canvas.getContext(\"webgl\");\n    if (webGLContext == null) {\n      continue;\n    }\n\n    if (webGLContext.__uuid == null) {\n      webGLContext.__uuid = glpHelpers.guid();\n    }\n\n    var name = null;\n    if (canvas.id) {\n      name = canvas.id;\n    } else if (canvas.className) {\n      name = canvas.className;\n    } else {\n      name = \"canvas\" + counter++;\n    }\n    webGLContext.__name = name;\n\n    c.push(webGLContext);\n  }\n\n  return c;\n}\n\ncontexts.sendContexts = function() {\n  var c = glpContexts.getWebGLContexts();\n  window.postMessage({\n    \"source\": \"content\",\n    \"type\": messageType.GET_CONTEXTS,\n    \"data\": {\"contexts\": JSON.stringify(c)}\n  }, \"*\");\n}\n\ncontexts.getWebGLContext = function(uuid) {\n  var c = this.getWebGLContexts();\n  for (var i = 0; i < c.length; i++) {\n    if (c[i].__uuid == uuid) {\n      return c[i];\n    }\n  }\n  return null;\n}\n\nreturn contexts;\n}());\nvar glpMessages = function (gl) {\n  this.gl = gl;\n}\n\n\/**\n * Sends messages to the devtools panel\n * @param {WebGLContext} The WebGL Context the Message is sent from.\n * @param {String} Message type\n * @param {Dictionary} Message data\n *\/\nglpMessages.prototype.sendMessage = function(type, data) {\n  window.postMessage({\n    \"source\": \"content\",\n    \"activeContext\": this.gl.__uuid,\n    \"type\": type,\n    \"data\": data\n  }, \"*\");\n}\n\nglpMessages.prototype.getCurrentProgramUsageCount = function() {\n  this.sendMessage(\n    messageType.GET_PROGRAM_USAGE_COUNT,\n    {\"programUsageCount\": JSON.stringify(this.gl.glp().programUsageCounter.usages)}\n  );\n}\n\n\/**\n * Gets duplicate programs list from the time that enable is called\n * Sends duplicated program list to the front end\n *\/\nglpMessages.prototype.getDuplicateProgramUsage = function() {\n  this.sendMessage(\n    messageType.GET_DUPLICATE_PROGRAM_USAGE,\n    {\"duplicateProgramUses\": JSON.stringify(this.gl.glp().duplicateProgramDetection.duplicates)}\n  );\n}\n\nglpMessages.prototype.getTextures = function() {\n  this.gl.glp().textureViewer.getTextures();\n}\n\nglpMessages.prototype.getTexture = function(index) {\n  this.gl.glp().textureViewer.getTexture(index);\n}\n\n\/**\n * Sends call stack information to the panel\n *\/\nglpMessages.prototype.sendCallStack = function() {\n  var callStack = this.gl.glp().callStack.getStack();\n  this.sendMessage(\n    messageType.CALL_STACK,\n    {\"functionNames\": callStack}\n  );\n}\n\n\/**\n * Sends call stack information for recent draw call to the panel\n *\/\nglpMessages.prototype.sendCallStackDraw = function() {\n  var callStack = this.gl.glp().callStack.getStackDraw();\n  this.sendMessage(\n    messageType.CALL_STACK_DRAW,\n    {\"functionNames\": callStack}\n  );\n}\n\n\/**\n * Sends histogram of function calls to the panel\n *\/\nglpMessages.prototype.sendFunctionHistogram = function(threshold) {\n  var dataSeries = []\n  var labels = []\n  var histogram = this.gl.glp().histogram.histogram\n  for (var functionName in histogram) {\n      if (histogram[functionName] >= threshold) {\n          labels.push(functionName)\n          dataSeries.push(histogram[functionName])\n      }\n  }\n\n  this.sendMessage(\n    messageType.FUNCTION_HISTOGRAM,\n    {\"labels\": labels, \"values\": dataSeries}\n  );\n}\n\n\/**\n * Toggles the status of the pixel inspector being enabled\/disabled\n * @param {Bool} Enabled\n *\/\nglpMessages.prototype.pixelInspectorToggle = function(enabled) {\n  if (enabled) {\n    this.gl.glp().pixelInspector.enable();\n  } else {\n    this.gl.glp().pixelInspector.disable();\n  }\n}\n\n\/**\n * Toggles the status of the mipmapViewer being enabled\/disabled\n * @param {Bool} Enabled\n * @param {UUID} uuid of the texture\n *\/\nglpMessages.prototype.mipmapViewerToggle = function(enabled, texture) {\n  if (enabled) {\n    this.gl.glp().mipmapViewer.enable(texture);\n  } else {\n    this.gl.glp().mipmapViewer.disable();\n  }\n}\n\nglpMessages.prototype.mipmapGetTextures = function() {\n  this.sendMessage(\n    messageType.MIPMAP_TEXTURES,\n    {\n      \"textures\": JSON.stringify(this.gl.glp().mipmapViewer.getTextureList())\n    })\n}\n\/**\n * Toggles the status of the depth inspector being enabled\/disabled\n * @param {Bool} Enabled\n * @param {Object} {near: float, far: float}\n *\/\nglpMessages.prototype.depthInspectorToggle = function(enabled, range) {\n  if (enabled) {\n    this.gl.glp().depthInspector.enable(range.near, range.far);\n  } else {\n    this.gl.glp().depthInspector.disable();\n  }\n}\n\n\/**\n * Sends call state variable information to the panel\n *\/\nglpMessages.prototype.sendStateVars = function(data) {\n  if (data != \"getStateVariables\") {\n      if (data.type == \"bool\") {\n        this.gl.glp().stateTracker.toggleBoolState(data);\n      } else if (data.type == \"num\") {\n        this.gl.glp().stateTracker.changeNumberState(data);\n      } else if (data.type == \"enum\") {\n        this.gl.glp().stateTracker.changeEnumState(data);\n      }\n  }\n  var stateVars = JSON.stringify(this.gl.glp().stateTracker.getStates());\n  var enumOptions = JSON.stringify(this.gl.glp().stateTracker.getEnumOptions());\n  this.sendMessage(\n    messageType.STATE_VARS,\n    {\n      \"stateVars\": stateVars,\n      \"enumOptions\": enumOptions\n    })\n}\n\nglpMessages.prototype.getShaders = function() {\n  shaders = []\n  var programs = this.gl.glp().shaderViewer.programIDs;\n  for (var i=0; i<programs.length; i++) {\n    var sources = this.gl.glp().shaderViewer.getShaderSources(programs[i]);\n    if (sources.length == 0) {\n      continue;\n    }\n\n    shaders.push({\n      \"programId\" : programs[i],\n      \"shaderSources\" : sources\n    });\n  }\n\n  this.sendMessage(\n    messageType.SHADERS,\n    JSON.stringify(shaders)\n  );\n}\n\/**\n * Instantiates messaging with the devtools panel\n *\/\nfunction _glpInit() {\n    window.postMessage({ type: \"init\" }, \"*\");\n}\n_glpInit();\n\n\/\/ Send contexts whenever page is loaded\ndocument.addEventListener(\"DOMContentLoaded\", setTimeout(glpContexts.sendContexts, 500));\n\n\/**\n * Receive messages from the devtools panel\n *\/\nwindow.addEventListener(\'message\', function(event) {\n  var message = event.data;\n\n  \/\/ Only accept messages that we know are ours\n  if (typeof message !== \'object\' || message === null || message.source != \"panel\") {\n    return;\n  }\n\n  if (message.type == messageType.GET_CONTEXTS) {\n    glpContexts.sendContexts();\n    return;\n  }\n\n  \/\/ TODO: verify that all features are disabled\n  var disableContext = function(gl) {\n    gl.glp().messages.pixelInspectorToggle(false);\n    gl.glp().callStack.toggle(false);\n    gl.glp().histogram.toggle(false);\n    gl.glp().programUsageCounter.toggle(false);\n    gl.glp().programUsageCounter.reset();\n    gl.glp().duplicateProgramDetection.toggle(false);\n    gl.glp().stateTracker.toggle(false);\n    gl.glp().messages.depthInspectorToggle(false, null);\n    gl.glp().frameControl.play();\n    gl.glp().mipmapViewer.disable();\n  }\n\n  if (message.type == messageType.DISABLE_ALL_CONTEXTS) {\n    \/\/ Dev panel closed -- disable all features\n    var c = glpContexts.getWebGLContexts();\n    for (var i = 0; i < c.length; i++) {\n      disableContext(c[i]);\n    }\n  }\n\n  var gl = glpContexts.getWebGLContext(message.activeContext);\n  if (!gl) {\n    return;\n  }\n\n  if (message.type == messageType.PIXEL_INSPECTOR) {\n    gl.glp().messages.pixelInspectorToggle(message.data.enabled);\n  } else if (message.type == messageType.DEPTH_INSPECTOR) {\n    gl.glp().messages.depthInspectorToggle(message.data.enabled, message.data.range);\n  } else if (message.type == messageType.ENABLE_MIPMAP_TEXTURE) {\n    gl.glp().messages.mipmapViewerToggle(message.data.enabled, message.data.texture);\n  } else if (message.type == messageType.MIPMAP_TEXTURES) {\n    gl.glp().messages.mipmapGetTextures();\n  } else if (message.type == messageType.GET_CALL_STACK) {\n    gl.glp().messages.sendCallStack(message.data);\n  } else if (message.type == messageType.GET_CALL_STACK_DRAW) {\n    gl.glp().messages.sendCallStackDraw(message.data);\n  } else if (message.type == messageType.TOGGLE_CALL_STACK) {\n    gl.glp().callStack.toggle(message.data.enabled);\n  } else if (message.type == messageType.TOGGLE_FUNCTION_HISTOGRAM) {\n    gl.glp().histogram.toggle(message.data.enabled);\n  } else if (message.type == messageType.FUNCTION_HISTOGRAM) {\n    gl.glp().messages.sendFunctionHistogram(message.data.threshold);\n  } else if (message.type == messageType.TOGGLE_PROGRAM_USAGE_COUNT) {\n    gl.glp().programUsageCounter.toggle(message.data.enabled);\n  } else if (message.type == messageType.RESET_PROGRAM_USAGE_COUNT) {\n    gl.glp().programUsageCounter.reset();\n  } else if (message.type == messageType.GET_PROGRAM_USAGE_COUNT) {\n    gl.glp().messages.getCurrentProgramUsageCount();\n  } else if (message.type == messageType.TOGGLE_DUPLICATE_PROGRAM_USAGE) {\n    gl.glp().duplicateProgramDetection.toggle(message.data.enabled);\n  } else if (message.type == messageType.RESET_DUPLICATE_PROGRAM_USAGE) {\n    gl.glp().duplicateProgramDetection.reset();\n  } else if (message.type == messageType.GET_DUPLICATE_PROGRAM_USAGE) {\n    gl.glp().messages.getDuplicateProgramUsage();\n  } else if (message.type == messageType.GET_TEXTURE) {\n    gl.glp().messages.getTexture(message.data.index);\n  } else if (message.type == messageType.GET_TEXTURES) {\n    gl.glp().messages.getTextures();\n  } else if (message.type == messageType.GET_BUFFER) {\n    gl.glp().bufferViewer.getBuffer(message.data.index);\n  } else if (message.type == messageType.GET_BUFFERS) {\n    gl.glp().bufferViewer.getBuffers();\n  } else if (message.type == messageType.GET_FRAME_BUFFER) {\n    gl.glp().bufferViewer.getFrameBuffer(message.data.index);\n  } else if (message.type == messageType.GET_FRAME_BUFFERS) {\n    gl.glp().bufferViewer.getFrameBuffers();\n  } else if (message.type == messageType.GET_RENDER_BUFFER) {\n    gl.glp().bufferViewer.getRenderBuffer(message.data.index);\n  } else if (message.type == messageType.GET_RENDER_BUFFERS) {\n    gl.glp().bufferViewer.getRenderBuffers();\n  } else if (message.type == messageType.STATE_VARS) {\n    gl.glp().messages.sendStateVars(message.data);\n  } else if (message.type == messageType.TOGGLE_STATE_VARS) {\n    gl.glp().stateTracker.toggle(message.data.enabled);\n  } else if (message.type == messageType.FRAME_CONTROL_PLAY) {\n    gl.glp().frameControl.play();\n  } else if (message.type == messageType.FRAME_CONTROL_PAUSE) {\n    gl.glp().frameControl.pause();\n  } else if (message.type == messageType.FRAME_CONTROL_NEXT_FRAME) {\n    gl.glp().frameControl.nextFrame();\n  } else if (message.type == messageType.DISABLE_ALL) {\n    disableContext(gl);\n  } else if (message.type == messageType.SHADERS) {\n    gl.glp().messages.getShaders();\n  } else {\n    console.error(message.type, message.data);\n  }\n});\nvar glpCallStack = function (gl) {\n  this.gl = gl;\n\n  this.enabled = false;\n  this.maxSize = 100;\n  this.mostRecentCalls = [];\n  this.callsSinceDraw = [];\n}\nglpCallStack.prototype.helper = {}\n\n\/*\n * Determines which file and line number called a certain function\n * Other things we can see other than line number include but are not limited to:\n * getThis, getTypeName, getFunction, getFunctionName, getMethodName, getFileName, getLineNumber,\n * getColumnNumber, getEvalOrigin, isToplevel, isEval, isNative, isConstructor\n *\n * To see more details, go to\n * http:\/\/stackoverflow.com\/questions\/11386492\/accessing-line-number-in-v8-javascript-chrome-node-js\n * https:\/\/github.com\/v8\/v8\/wiki\/Stack%20Trace%20API\n*\/\nglpCallStack.prototype.helper.getStack = function() {\n    var orig = Error.prepareStackTrace;\n    Error.prepareStackTrace = function(_, stack){ return stack; };\n    var err = new Error;\n    Error.captureStackTrace(err, arguments.callee);\n    var stack = err.stack;\n    Error.prepareStackTrace = orig;\n    return stack;\n}\n\n\/**\n * Returns \"FileName:LineNumber\" of requested call site\n * @param {CallSite} call site object\n *\/\nglpCallStack.prototype.helper.getCallSiteDetails = function(stack) {\n  if (!stack) {\n    return \"\";\n  }\n  return stack.getFileName() + \":\" + stack.getLineNumber();\n}\n\n\/**\n * Returns the first call stack trace from the user\n *\/\nglpCallStack.prototype.helper.getFirstUserStack = function() {\n  fullStack = this.getStack()\n  for(var i = 1; i < fullStack.length; i++) {\n    if (!~fullStack[i].getFileName().indexOf(\"src\/content_script\")) {\n      return fullStack[i];\n    }\n  }\n\n  return null;\n}\n\nglpCallStack.prototype.toggle = function(enabled) {\n  this.enabled = enabled;\n}\n\n\/**\n * Returns the call stack of the requested type\n * CallSite details (filename and line number) are processed\n * only on request because it\'s too expensive at storage time\n * @param {String} \"mostRecentCalls\" or \"callsSinceDraw\"\n *\/\nglpCallStack.prototype.getStack = function() {\n  mostRecentCalls = this.mostRecentCalls;\n\n  for (var i = 0; i < mostRecentCalls.length; i++) {\n    if (!mostRecentCalls[i].formatted) {\n      mostRecentCalls[i].name = mostRecentCalls[i].name + \" (\" + this.helper.getCallSiteDetails(mostRecentCalls[i].callSite) + \")\";\n      mostRecentCalls[i].args = JSON.stringify(mostRecentCalls[i].args);\n      mostRecentCalls[i].formatted = true;\n    }\n }\n return mostRecentCalls;\n}\n\nglpCallStack.prototype.getStackDraw = function() {\n  callsSinceDraw = this.callsSinceDraw;\n\n  for (var i = 0; i < callsSinceDraw.length; i++) {\n    if (!callsSinceDraw[i].formatted) {\n      callsSinceDraw[i].name = callsSinceDraw[i].name + \" (\" + this.helper.getCallSiteDetails(callsSinceDraw[i].callSite) + \")\";\n      callsSinceDraw[i].args = JSON.stringify(callsSinceDraw[i].args);\n      callsSinceDraw[i].formatted = true;\n    }\n  }\n  return callsSinceDraw;\n}\n\n\/**\n * Formats a date object to HH:MM:SS.mmm\n * @param {Date} d\n *\/\nglpCallStack.prototype.helper.dateTimeFormat = function(d) {\n  return d.getHours() + \":\"\n      + (\'00\'+d.getMinutes()).substring(d.getMinutes().toString().length) + \":\"\n      + (\'00\'+d.getSeconds()).substring(d.getSeconds().toString().length) + \".\"\n      + (\'000\'+d.getMilliseconds()).substring(d.getMilliseconds().toString().length);\n}\n\n\/**\n * Adds a new function to the call stack\n * @param {String} Name of function\n * @param {Dictionary} arguments used by the function\n *\/\nglpCallStack.prototype.push = function(name, args) {\n  if (!this.enabled) {\n    return;\n  }\n  var d = new Date();\n  var timeString = this.helper.dateTimeFormat(d);\n  var stack = this.helper.getFirstUserStack();\n  var callDetails = {\n    name: name,\n    args: args,\n    time: window.performance.now(),\n    executionTime: timeString,\n    callSite: stack,\n    formatted: false,\n  };\n  \/\/JSON.stringify(args)\n  if (this.mostRecentCalls.length > this.maxSize) {\n    this.mostRecentCalls.shift();\n  }\n  this.mostRecentCalls.push(callDetails);\n\n  var lastFunction = this.callsSinceDraw[this.callsSinceDraw.length - 1];\n  if (lastFunction &&\n      (lastFunction.name == \"drawElements\" || lastFunction.name == \"drawArrays\")) {\n    this.callsSinceDraw = [];\n  }\n  this.callsSinceDraw.push(callDetails);\n}\n\n\/**\n * Used post function call to update time elapsed\n * @param {String} Name of function\n * @param {CallSite} Obtained from getFirstUserStack\n *\/\nglpCallStack.prototype.update = function(name) {\n  if (!this.enabled) {\n    return;\n  }\n  var endTime = window.performance.now();\n  if (this.callsSinceDraw.length > 0) {\n    var i = this.callsSinceDraw.length - 1\n    \/\/ Most of the time we just need to update the last element on the stack,\n    \/\/ but there are rare cases of nesting where we have to trace backwards\n    while (i > 0 && this.callsSinceDraw[i].name != name) {\n      i--;\n    }\n    \/\/ \"| 0\" truncates to an int.  \"+ 0.5\" is for rounding\n    this.callsSinceDraw[i].time = (((endTime - this.callsSinceDraw[i].time) * 1000) + 0.5) | 0\n  }\n}\nvar glpHistogram = function (gl) {\n    this.gl = gl;\n\n    this.enabled = false;\n    this.histogram = {};\n}\n\n\/**\n * Adds a data point to the function histogram\n * @param {String} Name of function\n *\/\nglpHistogram.prototype.add = function(name) {\n  if (!this.enabled) {\n    return;\n  }\n  if (!this.histogram[name]) {\n    this.histogram[name] = 1;\n  } else {\n    this.histogram[name] += 1;\n  }\n}\n\nglpHistogram.prototype.toggle = function(enabled) {\n  this.enabled = enabled;\n}\nvar glpStateTracker = function (gl) {\n  this.gl = gl;\n  this.enabled = false;\n\n  \/\/bool\n  this.BLEND = null;\n  this.CULL_FACE = null;\n  this.DEPTH_TEST = null;\n  this.DEPTH_WRITEMASK = null;\n  this.DITHER = null;\n  this.POLYGON_OFFSET_FILL = null;\n  this.SAMPLE_COVERAGE_INVERT = null;\n  this.SCISSOR_TEST = null;\n  this.STENCIL_TEST = null;\n  this.UNPACK_FLIP_Y_WEBGL = null;\n  this.UNPACK_PREMULTIPLY_ALPHA_WEBGL = null;\n  \/\/numbers\n  this.ALPHA_BITS = null;\n  this.BLUE_BITS = null;\n  this.DEPTH_BITS = null;\n  this.DEPTH_CLEAR_VALUE = null;\n  this.GREEN_BITS = null;\n  this.LINE_WIDTH = null;\n  this.MAX_COMBINED_TEXTURE_IMAGE_UNITS = null;\n  this.MAX_CUBE_MAP_TEXTURE_SIZE = null;\n  this.MAX_FRAGMENT_UNIFORM_VECTORS = null;\n  this.MAX_RENDERBUFFER_SIZE = null;\n  this.MAX_TEXTURE_IMAGE_UNITS = null;\n  this.MAX_TEXTURE_SIZE = null;\n  this.MAX_VARYING_VECTORS = null;\n  this.MAX_VERTEX_ATTRIBS = null;\n  this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = null;\n  this.MAX_VERTEX_UNIFORM_VECTORS = null;\n  this.PACK_ALIGNMENT = null;\n  this.POLYGON_OFFSET_FACTOR = null;\n  this.POLYGON_OFFSET_UNITS = null;\n  this.RED_BITS = null;\n  this.SAMPLE_BUFFERS = null;\n  this.SAMPLE_COVERAGE_VALUE = null;\n  this.SAMPLES = null;\n  this.STENCIL_BACK_REF = null;\n  this.STENCIL_BITS = null;\n  this.STENCIL_CLEAR_VALUE = null;\n  this.STENCIL_REF = null;\n  this.SUBPIXEL_BITS = null;\n  this.UNPACK_ALIGNMENT = null;\n  \/\/enum\n  this.ACTIVE_TEXTURE = null;\n  this.BLEND_DST_ALPHA = null;\n  this.BLEND_DST_RGB = null;\n  this.BLEND_EQUATION_ALPHA = null;\n  this.BLEND_EQUATION_RGB = null;\n  this.BLEND_SRC_ALPHA = null;\n  this.BLEND_SRC_RGB = null;\n  this.CULL_FACE_MODE = null;\n  this.DEPTH_FUNC = null;\n  this.FRONT_FACE = null;\n  this.GENERATE_MIPMAP_HINT = null;\n  this.IMPLEMENTATION_COLOR_READ_FORMAT = null;\n  this.IMPLEMENTATION_COLOR_READ_TYPE = null;\n  this.STENCIL_BACK_FAIL = null;\n  this.STENCIL_BACK_FUNC = null;\n  this.STENCIL_BACK_PASS_DEPTH_FAIL = null;\n  this.STENCIL_BACK_PASS_DEPTH_PASS = null;\n  this.STENCIL_FAIL = null;\n  this.STENCIL_FUNC = null;\n  this.STENCIL_PASS_DEPTH_FAIL = null;\n  this.STENCIL_PASS_DEPTH_PASS = null;\n  this.UNPACK_COLORSPACE_CONVERSION_WEBGL = null;\n  this.programRequestedStates = {\n    bool: {\n      BLEND: null,\n      CULL_FACE: null,\n      DEPTH_TEST: null,\n      DEPTH_WRITEMASK: null, \/\/gl.depthMask(false);\n      DITHER: null,\n      POLYGON_OFFSET_FILL: null,\n      SAMPLE_COVERAGE_INVERT: null,\n      SCISSOR_TEST: null,\n      STENCIL_TEST: null,\n      UNPACK_FLIP_Y_WEBGL: null, \/\/gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n      UNPACK_PREMULTIPLY_ALPHA_WEBGL: null, \/\/gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n    },\n    number: {\n      ALPHA_BITS: null,\n      BLUE_BITS: null,\n      DEPTH_BITS: null,\n      DEPTH_CLEAR_VALUE: null, \/\/gl.clearDepth(depth); range = [0,1]\n      GREEN_BITS: null,\n      LINE_WIDTH: null, \/\/gl.lineWidth(width);\n      MAX_COMBINED_TEXTURE_IMAGE_UNITS: null, \/\/gl.activeTexture(texture);\n      MAX_CUBE_MAP_TEXTURE_SIZE: null,\n      MAX_FRAGMENT_UNIFORM_VECTORS: null,\n      MAX_RENDERBUFFER_SIZE: null,\n      MAX_TEXTURE_IMAGE_UNITS: null,\n      MAX_TEXTURE_SIZE: null,\n      MAX_VARYING_VECTORS: null,\n      MAX_VERTEX_ATTRIBS: null,\n      MAX_VERTEX_TEXTURE_IMAGE_UNITS: null,\n      MAX_VERTEX_UNIFORM_VECTORS: null,\n      PACK_ALIGNMENT: null, \/\/gl.pixelStorei(gl.PACK_ALIGNMENT, param); param in {1, 2, 4, 8}\n      POLYGON_OFFSET_FACTOR: null, \/\/gl.polygonOffset(factor, unit);\n      POLYGON_OFFSET_UNITS: null, \/\/gl.polygonOffset(factor, unit);\n      RED_BITS: null,\n      SAMPLE_BUFFERS: null,\n      SAMPLE_COVERAGE_VALUE: null,\n      SAMPLES: null,\n      STENCIL_BACK_REF: null, \/\/gl.stencilFuncSeparate(gl.BACK, gl.STENCIL_BACK_FUNC, 0.2, STENCIL_BACK_VALUE_MASK);\n      STENCIL_BITS: null,\n      STENCIL_CLEAR_VALUE: null,\n      STENCIL_REF: null, \/\/gl.stencilFunc(gl.STENCIL_FUNC, STENCIL_REF, STENCIL_BACK_VALUE_MASK);\n      SUBPIXEL_BITS: null,\n      UNPACK_ALIGNMENT: null, \/\/gl.pixelStorei(gl.UNPACK_ALIGNMENT, param); param in {1, 2, 4, 8}\n    },\n    enums: {\n      ACTIVE_TEXTURE: null, \/\/gl.activeTexture(texture);\n      BLEND_DST_ALPHA: null, \/\/gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);\n      BLEND_DST_RGB: null, \/\/gl.blendFuncSeparate\n      BLEND_EQUATION_ALPHA: null, \/\/gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_SUBTRACT);\n      BLEND_EQUATION_RGB: null, \/\/gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_SUBTRACT);\n      BLEND_SRC_ALPHA: null, \/\/gl.blendFuncSeparate\n      BLEND_SRC_RGB: null, \/\/gl.blendFuncSeparate\n      CULL_FACE_MODE: null, \/\/gl.cullFace(mode);\n      DEPTH_FUNC: null, \/\/gl.depthFunc(func);\n      FRONT_FACE: null, \/\/gl.frontFace(mode);\n      GENERATE_MIPMAP_HINT: null,\n      IMPLEMENTATION_COLOR_READ_FORMAT: null,\n      IMPLEMENTATION_COLOR_READ_TYPE: null,\n      STENCIL_BACK_FAIL: null,\n      STENCIL_BACK_FUNC: null,\n      STENCIL_BACK_PASS_DEPTH_FAIL: null,\n      STENCIL_BACK_PASS_DEPTH_PASS: null,\n      STENCIL_FAIL: null,\n      STENCIL_FUNC: null,\n      STENCIL_PASS_DEPTH_FAIL: null,\n      STENCIL_PASS_DEPTH_PASS: null,\n      UNPACK_COLORSPACE_CONVERSION_WEBGL: null, \/\/gl.pixelstorei(pname, param);\n    }\n  };\n}\n\n\nglpStateTracker.prototype.toggle = function(enabled) {\n  var gl = this.gl\n  if (enabled) {\n    this.enabled = true;\n    for (var type in this.programRequestedStates) {\n      for (var key in this.programRequestedStates[type]) {\n        this.programRequestedStates[type][key] = gl.getParameter(gl[key]);\n      }\n    }\n  } else {\n    for (var key in this.programRequestedStates.bool) {\n      this.toggleBoolState({\n        variable: key,\n        enable: this.programRequestedStates.bool[key]\n      })\n    }\n    for (var key in this.programRequestedStates.number) {\n      this.changeNumberState({\n        variable: key,\n        value: this.programRequestedStates.number[key]\n      })\n    }\n    for (var key in this.programRequestedStates.enums) {\n      this.changeEnumState({\n        variable: key,\n        value: glpHelpers.getGLEnumName(this.gl, this.programRequestedStates.enums[key])\n      })\n    }\n    this.enabled = false;\n  }\n}\n\nglpStateTracker.prototype.freezeStencilStates = function(face, value) {\n  var gl = this.gl;\n  if (face == gl.FRONT) {\n    return this.freezeStates(gl.STENCIL_REF, value);\n  } else if (face == gl.BACK) {\n    return this.freezeStates(gl.STENCIL_BACK_REF, value);\n  } else {\n    return this.freezeStates(gl.STENCIL_REF, value) || this.freezeStates(gl.STENCIL_BACK_REF, value);\n  }\n}\n\nglpStateTracker.prototype.freezeStates = function(stateEnum, value) {\n  if (!this.enabled) {\n    return false;\n  }\n  stateName = glpHelpers.getGLEnumName(this.gl, stateEnum)\n  if (this.programRequestedStates.enums[stateName] != null) {\n    if (this[stateName] != glpHelpers.getGLEnumName(this.gl, value)) {\n      this.programRequestedStates.enums[stateName] = value;\n      return true;\n    }\n  } else if (this[stateName] != value) {\n    if (typeof(value) === \"boolean\") {\n      this.programRequestedStates.bool[stateName] = value;\n    } else {\n      this.programRequestedStates.number[stateName] = value;\n    }\n    return true;\n  }\n  return false;\n}\n\nglpStateTracker.prototype.changeNumberState = function(request) {\n  if (!this.enabled) {\n    return false;\n  }\n  var gl = this.gl;\n  stateName = request.variable;\n  this[stateName] = request.value;\n  if (stateName == \"DEPTH_CLEAR_VALUE\") {\n    gl.clearDepth(request.value);\n  } else if (stateName == \"LINE_WIDTH\") {\n    gl.lineWidth(request.value);\n  } else if (stateName == \"PACK_ALIGNMENT\" || stateName == \"UNPACK_ALIGNMENT\") {\n    gl.pixelStorei(gl[stateName], request.value);\n  } else if (stateName == \"POLYGON_OFFSET_FACTOR\") {\n    gl.polygonOffset(request.value, gl.getParameter(gl.POLYGON_OFFSET_UNITS));\n  } else if (stateName == \"POLYGON_OFFSET_UNITS\") {\n    gl.polygonOffset(gl.getParameter(gl.POLYGON_OFFSET_FACTOR), request.value);\n  } else if (stateName == \"STENCIL_REF\") {\n    gl.stencilFunc(gl.getParameter(gl.STENCIL_FUNC), request.value, gl.getParameter(gl.STENCIL_VALUE_MASK));\n  } else if (stateName == \"STENCIL_BACK_REF\") {\n    gl.stencilFuncSeparate(gl.BACK, gl.getParameter(gl.STENCIL_BACK_FUNC), request.value, gl.getParameter(gl.STENCIL_BACK_VALUE_MASK));\n  }\n}\n\nglpStateTracker.prototype.toggleBoolState = function(request) {\n  if (!this.enabled) {\n    return false;\n  }\n  var gl = this.gl;\n  stateName = request.variable;\n  this[stateName] = request.enable;\n  if (stateName == \"UNPACK_FLIP_Y_WEBGL\" || stateName == \"UNPACK_PREMULTIPLY_ALPHA_WEBGL\") {\n    gl.pixelStorei(gl[stateName], request.enable);\n  } else if (stateName == \"DEPTH_WRITEMASK\") {\n    gl.depthMask(request.enable);\n  } else if (request.enable) {\n    gl.enable(gl[stateName]);\n  } else {\n    gl.disable(gl[stateName]);\n  }\n}\n\nglpStateTracker.prototype.changeEnumState = function(request) {\n  if (!this.enabled) {\n    return false;\n  }\n  var gl = this.gl;\n  stateName = request.variable;\n  enumifiedValue = gl[request.value];\n  this[stateName] = request.value;\n  if (stateName == \"ACTIVE_TEXTURE\") {\n    gl.activeTexture(enumifiedValue);\n  } else if (stateName == \"BLEND_DST_ALPHA\") {\n    gl.blendFuncSeparate(gl.getParameter(gl.BLEND_SRC_RGB),\n                         gl.getParameter(gl.BLEND_DST_RGB),\n                         gl.getParameter(gl.BLEND_SRC_ALPHA),\n                         enumifiedValue);\n  } else if (stateName == \"BLEND_DST_RGB\") {\n    gl.blendFuncSeparate(gl.getParameter(gl.BLEND_SRC_RGB),\n                         enumifiedValue,\n                         gl.getParameter(gl.BLEND_SRC_ALPHA),\n                         gl.getParameter(gl.BLEND_DST_ALPHA));\n  } else if (stateName == \"BLEND_SRC_ALPHA\") {\n    gl.blendFuncSeparate(gl.getParameter(gl.BLEND_SRC_RGB),\n                         gl.getParameter(gl.BLEND_DST_RGB),\n                         enumifiedValue,\n                         gl.getParameter(gl.BLEND_DST_ALPHA));\n  } else if (stateName == \"BLEND_SRC_RGB\") {\n    gl.blendFuncSeparate(enumifiedValue,\n                         gl.getParameter(gl.BLEND_DST_RGB),\n                         gl.getParameter(gl.BLEND_SRC_ALPHA),\n                         gl.getParameter(gl.BLEND_DST_ALPHA));\n  } else if (stateName == \"BLEND_EQUATION_ALPHA\") {\n    gl.blendEquationSeparate(gl.getParameter(gl.BLEND_EQUATION_RGB), enumifiedValue);\n  } else if (stateName == \"BLEND_EQUATION_RGB\") {\n    gl.blendEquationSeparate(enumifiedValue, gl.getParameter(gl.BLEND_EQUATION_ALPHA));\n  } else if (stateName == \"CULL_FACE_MODE\") {\n    gl.cullFace(enumifiedValue);\n  } else if (stateName == \"DEPTH_FUNC\") {\n    gl.depthFunc(enumifiedValue);\n  } else if (stateName == \"FRONT_FACE\") {\n    gl.frontFace(enumifiedValue);\n  } else if (stateName == \"UNPACK_COLORSPACE_CONVERSION_WEBGL\") {\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, enumifiedValue);\n  }\n}\n\nglpStateTracker.prototype.getEnumOptions = function() {\n  var gl = this.gl\n  textureOptions = [];\n  for (var i = 0; i < gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS); i++) {\n    textureOptions.push(\"TEXTURE\" + i);\n  }\n  blendOptions = [\n    \"ONE\",\n    \"SRC_COLOR\",\n    \"ONE_MINUS_SRC_COLOR\",\n    \"DST_COLOR\",\n    \"ONE_MINUS_DST_COLOR\",\n    \"SRC_ALPHA\",\n    \"ONE_MINUS_SRC_ALPHA\",\n    \"ONE_MINUS_SRC_ALPHA\",\n    \"ONE_MINUS_DST_ALPHA\",\n    \"SRC_ALPHA_SATURATE\"\n  ];\n  return {\n    ACTIVE_TEXTURE: textureOptions,\n    BLEND_DST_ALPHA: blendOptions,\n    BLEND_DST_RGB: blendOptions,\n    BLEND_EQUATION_ALPHA: [\"FUNC_ADD\", \"FUNC_SUBTRACT\", \"FUNC_REVERSE_SUBTRACT\"],\n    BLEND_EQUATION_RGB: [\"FUNC_ADD\", \"FUNC_SUBTRACT\", \"FUNC_REVERSE_SUBTRACT\"],\n    BLEND_SRC_ALPHA: blendOptions,\n    BLEND_SRC_RGB: blendOptions,\n    CULL_FACE_MODE: [\"FRONT\", \"BACK\", \"FRONT_AND_BACK\"],\n    DEPTH_FUNC: [\"NEVER\", \"LESS\", \"EQUAL\", \"LEQUAL\", \"GREATER\", \"NOTEQUAL\", \"GEQUAL\", \"ALWAYS\"],\n    FRONT_FACE: [\"CW\", \"CCW\"],\n    GENERATE_MIPMAP_HINT: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.GENERATE_MIPMAP_HINT))],\n    IMPLEMENTATION_COLOR_READ_FORMAT: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT))],\n    IMPLEMENTATION_COLOR_READ_TYPE: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE))],\n    STENCIL_BACK_FAIL: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_BACK_FAIL))],\n    STENCIL_BACK_FUNC: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_BACK_FUNC))],\n    STENCIL_BACK_PASS_DEPTH_FAIL: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_BACK_PASS_DEPTH_FAIL))],\n    STENCIL_BACK_PASS_DEPTH_PASS: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_BACK_PASS_DEPTH_PASS))],\n    STENCIL_FAIL: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_FAIL))],\n    STENCIL_FUNC: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_FUNC))],\n    STENCIL_PASS_DEPTH_FAIL: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL))],\n    STENCIL_PASS_DEPTH_PASS: [glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS))],\n    UNPACK_COLORSPACE_CONVERSION_WEBGL: [\"BROWSER_DEFAULT_WEBGL\", \"NONE\"],\n  }\n}\n\nglpStateTracker.prototype.getStates = function() {\n  var boolStates = this.getBooleanStates();\n  var numberStates = this.getNumberStates();\n  var enumStates = this.getEnumStates();\n  var allStates = {};\n  for (var key in boolStates) {\n    allStates[key] = boolStates[key];\n  }\n  for (var key in numberStates) {\n    allStates[key] = numberStates[key];\n  }\n  for (var key in enumStates) {\n    allStates[key] = enumStates[key];\n  }\n  return allStates;\n}\n\n\/\/ BLEND *                             GLboolean\n\/\/ CULL_FACE *                         GLboolean\n\/\/ DEPTH_TEST *                        GLboolean\n\/\/ DEPTH_WRITEMASK                     GLboolean\n\/\/ DITHER *                            GLboolean\n\/\/ POLYGON_OFFSET_FILL *               GLboolean\n\/\/ SAMPLE_COVERAGE_INVERT *            GLboolean\n\/\/ SCISSOR_TEST *                      GLboolean\n\/\/ STENCIL_TEST *                      GLboolean\n\/\/ UNPACK_FLIP_Y_WEBGL                 GLboolean\n\/\/ UNPACK_PREMULTIPLY_ALPHA_WEBGL      GLboolean\nglpStateTracker.prototype.getBooleanStates = function() {\n  var gl = this.gl;\n\n  this.BLEND = gl.getParameter(gl.BLEND);\n  this.CULL_FACE = gl.getParameter(gl.CULL_FACE);\n  this.DEPTH_TEST = gl.getParameter(gl.DEPTH_TEST);\n  this.DEPTH_WRITEMASK = gl.getParameter(gl.DEPTH_WRITEMASK);\n  this.DITHER = gl.getParameter(gl.DITHER);\n  this.POLYGON_OFFSET_FILL = gl.getParameter(gl.POLYGON_OFFSET_FILL);\n  this.SCISSOR_TEST = gl.getParameter(gl.SCISSOR_TEST);\n  this.STENCIL_TEST = gl.getParameter(gl.STENCIL_TEST);\n  this.UNPACK_FLIP_Y_WEBGL = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n  this.UNPACK_PREMULTIPLY_ALPHA_WEBGL = gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL);\n  return {\n    BLEND: {value: this.BLEND, type:\"bool\"},\n    CULL_FACE: {value: this.CULL_FACE, type:\"bool\"},\n    DEPTH_TEST: {value: this.DEPTH_TEST, type:\"bool\"},\n    DEPTH_WRITEMASK: {value: this.DEPTH_WRITEMASK, type:\"bool\"},\n    DITHER: {value: this.DITHER, type:\"bool\"},\n    POLYGON_OFFSET_FILL: {value: this.POLYGON_OFFSET_FILL, type:\"bool\"},\n    SCISSOR_TEST: {value: this.SCISSOR_TEST, type:\"bool\"},\n    STENCIL_TEST: {value: this.STENCIL_TEST, type:\"bool\"},\n    UNPACK_FLIP_Y_WEBGL: {value: this.UNPACK_FLIP_Y_WEBGL, type:\"bool\"},\n    UNPACK_PREMULTIPLY_ALPHA_WEBGL: {value: this.UNPACK_PREMULTIPLY_ALPHA_WEBGL, type:\"bool\"},\n  }\n}\n\n\/\/ ALPHA_BITS                          GLint\n\/\/ BLUE_BITS                           GLint\n\/\/ DEPTH_BITS                          GLint\n\/\/ DEPTH_CLEAR_VALUE                   GLfloat\n\/\/ GREEN_BITS                          GLint\n\/\/ LINE_WIDTH                          GLfloat\n\/\/ MAX_COMBINED_TEXTURE_IMAGE_UNITS    GLint\n\/\/ MAX_CUBE_MAP_TEXTURE_SIZE           GLint\n\/\/ MAX_FRAGMENT_UNIFORM_VECTORS        GLint\n\/\/ MAX_RENDERBUFFER_SIZE               GLint\n\/\/ MAX_TEXTURE_IMAGE_UNITS             GLint\n\/\/ MAX_TEXTURE_SIZE                    GLint\n\/\/ MAX_VARYING_VECTORS                 GLint\n\/\/ MAX_VERTEX_ATTRIBS                  GLint\n\/\/ MAX_VERTEX_TEXTURE_IMAGE_UNITS      GLint\n\/\/ MAX_VERTEX_UNIFORM_VECTORS          GLint\n\/\/ PACK_ALIGNMENT                      GLint\n\/\/ POLYGON_OFFSET_FACTOR               GLfloat\n\/\/ POLYGON_OFFSET_UNITS                GLfloat\n\/\/ RED_BITS                            GLint\n\/\/ SAMPLE_BUFFERS                      GLint\n\/\/ SAMPLE_COVERAGE_VALUE               GLfloat\n\/\/ SAMPLES                             GLint\n\/\/ STENCIL_BACK_REF                    GLint\n\/\/ STENCIL_BITS                        GLint\n\/\/ STENCIL_CLEAR_VALUE                 GLint\n\/\/ STENCIL_REF                         GLint\n\/\/ SUBPIXEL_BITS                       GLint\n\/\/ UNPACK_ALIGNMENT                    GLint\nglpStateTracker.prototype.getNumberStates = function() {\n  var gl = this.gl;\n  this.ALPHA_BITS = gl.getParameter(gl.ALPHA_BITS);\n  this.BLUE_BITS = gl.getParameter(gl.BLUE_BITS);\n  this.DEPTH_BITS = gl.getParameter(gl.DEPTH_BITS);\n  this.DEPTH_CLEAR_VALUE = gl.getParameter(gl.DEPTH_CLEAR_VALUE);\n  this.GREEN_BITS = gl.getParameter(gl.GREEN_BITS);\n  this.LINE_WIDTH = gl.getParameter(gl.LINE_WIDTH);\n  this.MAX_COMBINED_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n  this.MAX_CUBE_MAP_TEXTURE_SIZE = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n  this.MAX_FRAGMENT_UNIFORM_VECTORS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n  this.MAX_RENDERBUFFER_SIZE = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n  this.MAX_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  this.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  this.MAX_VARYING_VECTORS = gl.getParameter(gl.MAX_VARYING_VECTORS);\n  this.MAX_VERTEX_ATTRIBS = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n  this.MAX_VERTEX_UNIFORM_VECTORS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n  this.PACK_ALIGNMENT = gl.getParameter(gl.PACK_ALIGNMENT);\n  this.POLYGON_OFFSET_FACTOR = gl.getParameter(gl.POLYGON_OFFSET_FACTOR);\n  this.POLYGON_OFFSET_UNITS = gl.getParameter(gl.POLYGON_OFFSET_UNITS);\n  this.RED_BITS = gl.getParameter(gl.RED_BITS);\n  this.SAMPLE_BUFFERS = gl.getParameter(gl.SAMPLE_BUFFERS);\n  this.SAMPLE_COVERAGE_VALUE = gl.getParameter(gl.SAMPLE_COVERAGE_VALUE);\n  this.SAMPLES = gl.getParameter(gl.SAMPLES);\n  this.STENCIL_BACK_REF = gl.getParameter(gl.STENCIL_BACK_REF);\n  this.STENCIL_BITS = gl.getParameter(gl.STENCIL_BITS);\n  this.STENCIL_CLEAR_VALUE = gl.getParameter(gl.STENCIL_CLEAR_VALUE);\n  this.STENCIL_REF = gl.getParameter(gl.STENCIL_REF);\n  this.SUBPIXEL_BITS = gl.getParameter(gl.SUBPIXEL_BITS);\n  this.UNPACK_ALIGNMENT = gl.getParameter(gl.UNPACK_ALIGNMENT);\n  return {\n    ALPHA_BITS: {value: this.ALPHA_BITS, type: \"number\"},\n    BLUE_BITS: {value: this.BLUE_BITS, type: \"number\"},\n    DEPTH_BITS: {value: this.DEPTH_BITS, type: \"number\"},\n    DEPTH_CLEAR_VALUE: {value: this.DEPTH_CLEAR_VALUE, type: \"number\"},\n    GREEN_BITS: {value: this.GREEN_BITS, type: \"number\"},\n    LINE_WIDTH: {value: this.LINE_WIDTH, type: \"number\"},\n    MAX_COMBINED_TEXTURE_IMAGE_UNITS: {value: this.MAX_COMBINED_TEXTURE_IMAGE_UNITS, type: \"number\"},\n    MAX_CUBE_MAP_TEXTURE_SIZE: {value: this.MAX_CUBE_MAP_TEXTURE_SIZE, type: \"number\"},\n    MAX_FRAGMENT_UNIFORM_VECTORS: {value: this.MAX_FRAGMENT_UNIFORM_VECTORS, type: \"number\"},\n    MAX_RENDERBUFFER_SIZE: {value: this.MAX_RENDERBUFFER_SIZE, type: \"number\"},\n    MAX_TEXTURE_IMAGE_UNITS: {value: this.MAX_TEXTURE_IMAGE_UNITS, type: \"number\"},\n    MAX_TEXTURE_SIZE: {value: this.MAX_TEXTURE_SIZE, type: \"number\"},\n    MAX_VARYING_VECTORS: {value: this.MAX_VARYING_VECTORS, type: \"number\"},\n    MAX_VERTEX_ATTRIBS: {value: this.MAX_VERTEX_ATTRIBS, type: \"number\"},\n    MAX_VERTEX_TEXTURE_IMAGE_UNITS: {value: this.MAX_VERTEX_TEXTURE_IMAGE_UNITS, type: \"number\"},\n    MAX_VERTEX_UNIFORM_VECTORS: {value: this.MAX_VERTEX_UNIFORM_VECTORS, type: \"number\"},\n    PACK_ALIGNMENT: {value: this.PACK_ALIGNMENT, type: \"number\"},\n    POLYGON_OFFSET_FACTOR: {value: this.POLYGON_OFFSET_FACTOR, type: \"number\"},\n    POLYGON_OFFSET_UNITS: {value: this.POLYGON_OFFSET_UNITS, type: \"number\"},\n    RED_BITS: {value: this.RED_BITS, type: \"number\"},\n    SAMPLE_BUFFERS: {value: this.SAMPLE_BUFFERS, type: \"number\"},\n    SAMPLE_COVERAGE_VALUE: {value: this.SAMPLE_COVERAGE_VALUE, type: \"number\"},\n    SAMPLES: {value: this.SAMPLES, type: \"number\"},\n    STENCIL_BACK_REF: {value: this.STENCIL_BACK_REF, type: \"number\"},\n    STENCIL_BITS: {value: this.STENCIL_BITS, type: \"number\"},\n    STENCIL_CLEAR_VALUE: {value: this.STENCIL_CLEAR_VALUE, type: \"number\"},\n    STENCIL_REF: {value: this.STENCIL_REF, type: \"number\"},\n    SUBPIXEL_BITS: {value: this.SUBPIXEL_BITS, type: \"number\"},\n    UNPACK_ALIGNMENT: {value: this.UNPACK_ALIGNMENT, type: \"number\"},\n  }\n}\n\n\/\/ ACTIVE_TEXTURE                      GLenum\n\/\/ BLEND_DST_ALPHA                     GLenum\n\/\/ BLEND_DST_RGB                       GLenum\n\/\/ BLEND_EQUATION_ALPHA                GLenum\n\/\/ BLEND_EQUATION_RGB                  GLenum\n\/\/ BLEND_SRC_ALPHA                     GLenum\n\/\/ BLEND_SRC_RGB                       GLenum\n\/\/ CULL_FACE_MODE                      GLenum\n\/\/ DEPTH_FUNC                          GLenum\n\/\/ FRONT_FACE                          GLenum\n\/\/ GENERATE_MIPMAP_HINT                GLenum\n\/\/ IMPLEMENTATION_COLOR_READ_FORMAT    GLenum\n\/\/ IMPLEMENTATION_COLOR_READ_TYPE      GLenum\n\/\/ STENCIL_BACK_FAIL                   GLenum\n\/\/ STENCIL_BACK_FUNC                   GLenum\n\/\/ STENCIL_BACK_PASS_DEPTH_FAIL        GLenum\n\/\/ STENCIL_BACK_PASS_DEPTH_PASS        GLenum\n\/\/ STENCIL_FAIL                        GLenum\n\/\/ STENCIL_FUNC                        GLenum\n\/\/ STENCIL_PASS_DEPTH_FAIL             GLenum\n\/\/ STENCIL_PASS_DEPTH_PASS             GLenum\n\/\/ UNPACK_COLORSPACE_CONVERSION_WEBGL  GLenum\nglpStateTracker.prototype.getEnumStates = function() {\n  var gl = this.gl;\n  this.ACTIVE_TEXTURE =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.ACTIVE_TEXTURE));\n  this.BLEND_DST_ALPHA =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.BLEND_DST_ALPHA));\n  this.BLEND_DST_RGB =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.BLEND_DST_RGB));\n  this.BLEND_EQUATION_ALPHA =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.BLEND_EQUATION_ALPHA));\n  this.BLEND_EQUATION_RGB =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.BLEND_EQUATION_RGB));\n  this.BLEND_SRC_ALPHA =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.BLEND_SRC_ALPHA));\n  this.BLEND_SRC_RGB =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.BLEND_SRC_RGB));\n  this.CULL_FACE_MODE =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.CULL_FACE_MODE));\n  this.DEPTH_FUNC =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.DEPTH_FUNC));\n  this.FRONT_FACE =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.FRONT_FACE));\n  this.GENERATE_MIPMAP_HINT =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.GENERATE_MIPMAP_HINT));\n  this.IMPLEMENTATION_COLOR_READ_FORMAT =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT));\n  this.IMPLEMENTATION_COLOR_READ_TYPE =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE));\n  this.STENCIL_BACK_FAIL =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_BACK_FAIL));\n  this.STENCIL_BACK_FUNC =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_BACK_FUNC));\n  this.STENCIL_BACK_PASS_DEPTH_FAIL =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_BACK_PASS_DEPTH_FAIL));\n  this.STENCIL_BACK_PASS_DEPTH_PASS =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_BACK_PASS_DEPTH_PASS));\n  this.STENCIL_FAIL =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_FAIL));\n  this.STENCIL_FUNC =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_FUNC));\n  this.STENCIL_PASS_DEPTH_FAIL =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL));\n  this.STENCIL_PASS_DEPTH_PASS =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS));\n  this.UNPACK_COLORSPACE_CONVERSION_WEBGL =  glpHelpers.getGLEnumName(gl, gl.getParameter(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL));\n\n  return {\n    ACTIVE_TEXTURE: {value: this.ACTIVE_TEXTURE, type: \"enum\"},\n    BLEND_DST_ALPHA: {value: this.BLEND_DST_ALPHA, type: \"enum\"},\n    BLEND_DST_RGB: {value: this.BLEND_DST_RGB, type: \"enum\"},\n    BLEND_EQUATION_ALPHA: {value: this.BLEND_EQUATION_ALPHA, type: \"enum\"},\n    BLEND_EQUATION_RGB: {value: this.BLEND_EQUATION_RGB, type: \"enum\"},\n    BLEND_SRC_ALPHA: {value: this.BLEND_SRC_ALPHA, type: \"enum\"},\n    BLEND_SRC_RGB: {value: this.BLEND_SRC_RGB, type: \"enum\"},\n    CULL_FACE_MODE: {value: this.CULL_FACE_MODE, type: \"enum\"},\n    DEPTH_FUNC: {value: this.DEPTH_FUNC, type: \"enum\"},\n    FRONT_FACE: {value: this.FRONT_FACE, type: \"enum\"},\n    GENERATE_MIPMAP_HINT: {value: this.GENERATE_MIPMAP_HINT, type: \"enum\"},\n    IMPLEMENTATION_COLOR_READ_FORMAT: {value: this.IMPLEMENTATION_COLOR_READ_FORMAT, type: \"enum\"},\n    IMPLEMENTATION_COLOR_READ_TYPE: {value: this.IMPLEMENTATION_COLOR_READ_TYPE, type: \"enum\"},\n    STENCIL_BACK_FAIL: {value: this.STENCIL_BACK_FAIL, type: \"enum\"},\n    STENCIL_BACK_FUNC: {value: this.STENCIL_BACK_FUNC, type: \"enum\"},\n    STENCIL_BACK_PASS_DEPTH_FAIL: {value: this.STENCIL_BACK_PASS_DEPTH_FAIL, type: \"enum\"},\n    STENCIL_BACK_PASS_DEPTH_PASS: {value: this.STENCIL_BACK_PASS_DEPTH_PASS, type: \"enum\"},\n    STENCIL_FAIL: {value: this.STENCIL_FAIL, type: \"enum\"},\n    STENCIL_FUNC: {value: this.STENCIL_FUNC, type: \"enum\"},\n    STENCIL_PASS_DEPTH_FAIL: {value: this.STENCIL_PASS_DEPTH_FAIL, type: \"enum\"},\n    STENCIL_PASS_DEPTH_PASS: {value: this.STENCIL_PASS_DEPTH_PASS, type: \"enum\"},\n    UNPACK_COLORSPACE_CONVERSION_WEBGL: {value: this.UNPACK_COLORSPACE_CONVERSION_WEBGL, type: \"enum\"},\n  }\n}\n\n\/*\nOther states that work with getParameter()\npname                               returned type\nCOLOR_WRITEMASK                     sequence<GLboolean> (with 4 values)\nRENDERER                            DOMString\nSHADING_LANGUAGE_VERSION            DOMString\nVENDOR                              DOMString\nVERSION                             DOMString\nALIASED_LINE_WIDTH_RANGE            Float32Array (with 2 elements)\nALIASED_POINT_SIZE_RANGE            Float32Array (with 2 elements)\nDEPTH_RANGE                         Float32Array (with 2 elements)\nBLEND_COLOR                         Float32Array (with 4 values)\nCOLOR_CLEAR_VALUE                   Float32Array (with 4 values)\nSTENCIL_BACK_VALUE_MASK             GLuint\nSTENCIL_BACK_WRITEMASK              GLuint\nSTENCIL_VALUE_MASK                  GLuint\nSTENCIL_WRITEMASK                   GLuint\nMAX_VIEWPORT_DIMS                   Int32Array (with 2 elements)\nSCISSOR_BOX                         Int32Array (with 4 elements)\nVIEWPORT                            Int32Array (with 4 elements)\nCOMPRESSED_TEXTURE_FORMATS          Uint32Array\nARRAY_BUFFER_BINDING                WebGLBuffer\nELEMENT_ARRAY_BUFFER_BINDING        WebGLBuffer\nCURRENT_PROGRAM                     WebGLProgram\nFRAMEBUFFER_BINDING                 WebGLFramebuffer\nRENDERBUFFER_BINDING                WebGLRenderbuffer\nTEXTURE_BINDING_2D                  WebGLTexture\nTEXTURE_BINDING_CUBE_MAP            WebGLTexture\n*\/\nvar glpShaderViewer = function (gl) {\n  this.gl = gl;\n  this.programs = {};\n  this.programIDs = [];\n}\n\nglpShaderViewer.prototype.addProgram = function(program) {\n  this.programIDs.push(program.__uuid);\n  this.programs[program.__uuid] = program;\n}\n\nglpShaderViewer.prototype.getShaders = function(programId) {\n  var program = this.programs[programId];\n  return this.gl.getAttachedShaders(program)\n}\n\nglpShaderViewer.prototype.getShaderSources = function(programId) {\n  var shaderSources = [];\n  var shaders = this.getShaders(programId);\n  if (shaders == null) {\n    return [];\n  }\n\n  for (var i = 0; i < shaders.length; i++) {\n    shaderSources.push(this.gl.getShaderSource(shaders[i]));\n  }\n  return shaderSources;\n}\n\/*\n * Define all glp functions to be bound\n*\/\nvar glpFcnBindings = {\n    \/\/ The default function is called first before all other method calls\n    default: function(original, args, name) {\n      this.glp().callStack.push(name, args);\n      this.glp().histogram.add(name);\n      var ret = original.apply(this, args);\n      this.glp().callStack.update(name);\n      return ret;\n    },\n    attachShader : function(original, args, name) {\n      this.glp().pixelInspector.storeShaders(args[0], args[1]);\n      this.glp().depthInspector.storeShaders(args[0], args[1]);\n      return original.apply(this, args);\n    },\n    enable: function(original, args, name) {\n        if (this.glp().stateTracker.freezeStates(args[0], true)) {\n          return;\n        }\n        if (this.glp().pixelInspector.saveStates(args[0], true)) {\n          return;\n        }\n\n        return original.apply(this, args);\n    },\n    disable: function(original, args, name) {\n        if (this.glp().stateTracker.freezeStates(args[0], false)) {\n          return;\n        }\n        if (this.glp().pixelInspector.saveStates(args[0], false)) {\n          return;\n        }\n\n        return original.apply(this, args);\n    },\n    blendFunc: function(original, args, name) {\n        \/\/ TODO: verify valid input\n        if (this.glp().stateTracker.freezeStates(this.BLEND_SRC_RGB, args[0])) {\n          return;\n        }\n        if (this.glp().stateTracker.freezeStates(this.BLEND_DST_RGB, args[1])) {\n          return;\n        }\n        if (this.glp().pixelInspector.storeBlendStates(args[0], args[1])) {\n          return;\n        }\n        return original.apply(this, args);\n    },\n    blendFuncSeparate: function(original, args, name) {\n        \/\/ TODO: verify valid input\n        if (this.glp().stateTracker.freezeStates(this.BLEND_SRC_RGB, args[0])) {\n          return;\n        }\n        if (this.glp().stateTracker.freezeStates(this.BLEND_DST_RGB, args[1])) {\n          return;\n        }\n        if (this.glp().stateTracker.freezeStates(this.BLEND_SRC_ALPHA, args[2])) {\n          return;\n        }\n        if (this.glp().stateTracker.freezeStates(this.BLEND_DST_ALPHA, args[3])) {\n          return;\n        }\n        if (this.glp().pixelInspector.storeBlendStates(args[0], args[1])) {\n          return;\n        }\n        return original.apply(this, args);\n    },\n    clearColor: function(original, args, name) {\n        \/\/ TODO: verify valid input\n        if (this.glp().pixelInspector.storeClearColorStates(args)) {\n          return;\n        }\n        if (this.glp().depthInspector.storeClearColorStates(args)) {\n          return;\n        }\n        return original.apply(this, args);\n    },\n    useProgram: function(original, args, name) {\n        \/\/ glpPixelInspector: replace the program with pixel inspector program\n        \/\/ TODO: Handle case where program provided is the pixel inspector program\n        \/\/ TODO: verify valid input\n        var program = args[0];\n\n        this.glp().duplicateProgramDetection.useProgramCalled(program);\n\n        var retVal = original.apply(this, args);\n        if (program && this.glp().pixelInspector.enabled && !this.glp().pixelInspector.hasProgram(program)) {\n          this.glp().pixelInspector.switchToProgram();\n        }\n        if (program && this.glp().depthInspector.enabled && !this.glp().depthInspector.hasProgram(program)) {\n          this.glp().depthInspector.switchToProgram();\n        }\n\n        this.glp().programUsageCounter.addUsage(program);\n\n        return retVal;\n    },\n    getUniform: function(original, args, name) {\n      args = this.glp().depthInspector.uniforms(args);\n      args = this.glp().pixelInspector.uniforms(args);\n      return original.apply(this, args);\n    },\n    createProgram: function(original, args, name) {\n      var program = original.apply(this, args);\n      program.__uuid = glpHelpers.guid();\n      this.glp().shaderViewer.addProgram(program);\n      return program;\n    },\n    getUniformLocation: function(original, args, name) {\n      var program = args[0];\n      var n = args[1];\n      if (!(this.glp().pixelInspector.hasUniformLocation(program, n))) {\n        var location = original.apply(this, args);\n        if (!location) {\n          return;\n        }\n        return this.glp().pixelInspector.setUniformLocation(program, n, location);\n      }\n      if (!(this.glp().depthInspector.hasUniformLocation(program, n))) {\n        var location = original.apply(this, args);\n        if (!location) {\n          return;\n        }\n        return this.glp().depthInspector.setUniformLocation(program, n, location);\n      }\n      return this.glp().pixelInspector.getUniformLocation(program, n);\n    },\n    createTexture : function(original, args, name) {\n      var texture = original.apply(this, args);\n      this.glp().textureViewer.pushTexture(texture);\n      this.glp().mipmapViewer.pushTextureKey(texture);\n      return texture;\n    },\n    bindTexture : function(original, args, name) {\n      this.glp().textureViewer.bindTexture(args[0], args[1]);\n      this.glp().mipmapViewer.updateActiveTexture(args[1]);\n      return original.apply(this, args);\n    },\n    unbindTexture : function(original, args, name) {\n      this.glp().textureViewer.unbindTexture();\n      return original.apply(this, args);\n    },\n    texImage2D : function(original, args, name) {\n      this.glp().textureViewer.texImage2D(args);\n      this.glp().mipmapViewer.texImage2D(original, args);\n      return original.apply(this, args);\n    },\n    texSubImage2D : function(original, args, name) {\n      this.glp().textureViewer.texSubImage2D(args);\n      this.glp().mipmapViewer.texSubImage2D(original, args);\n      return original.apply(this, args);\n    },\n    texParameteri : function(original, args, name) {\n      this.glp().textureViewer.texParameteri(args);\n      this.glp().mipmapViewer.storeFunctions(original, args);\n      return original.apply(this, args);\n    },\n    texParameterf : function(original, args, name) {\n      this.glp().textureViewer.texParameterf(args);\n      this.glp().mipmapViewer.storeFunctions(original, args);\n      return original.apply(this, args);\n    },\n    createBuffer: function(original, args, name) {\n      var buffer = original.apply(this, args);\n      return this.glp().bufferViewer.pushBuffer(buffer);\n    },\n    createFramebuffer: function(original, args, name) {\n      var buffer = original.apply(this, args);\n      return this.glp().bufferViewer.pushFrameBuffer(buffer);\n    },\n    createRenderbuffer: function(original, args, name) {\n      var buffer = original.apply(this, args);\n      return this.glp().bufferViewer.pushRenderBuffer(buffer);\n    },\n    bindBuffer: function(original, args, name) {\n      this.glp().bufferViewer.bindBuffer(args[1]);\n      return original.apply(this, args);\n    },\n    unbindBuffer: function(original, args, name) {\n      this.glp().bufferViewer.unbindBuffer();\n      return original.apply(this, args);\n    },\n    bufferData: function(original, args, name) {\n      this.glp().bufferViewer.bufferData(args);\n      return original.apply(this, args);\n    },\n    bufferSubData: function(original, args, name) {\n      this.glp().bufferViewer.bufferSubData(args);\n      return original.apply(this, args);\n    },\n    deleteBuffer: function(original, args, name) {\n      this.glp().bufferViewer.deleteBuffer(args[0]);\n      return original.apply(this, args);\n    },\n    bindFramebuffer: function(original, args, name) {\n      this.glp().bufferViewer.bindFramebuffer(args[1]);\n      return original.apply(this, args);\n    },\n    unbindFramebuffer: function(original, args, name) {\n      this.glp().bufferViewer.unbindFramebuffer();\n      return original.apply(this, args);\n    },\n    deleteFramebuffer: function(original, args, name) {\n      this.glp().bufferViewer.deleteFramebuffer(args[0]);\n      return original.apply(this, args);\n    },\n    framebufferRenderbuffer: function(original, args, name) {\n      this.glp().bufferViewer.framebufferRenderbuffer(args);\n      return original.apply(this, args);\n    },\n    framebufferTexture2D: function(original, args, name) {\n      this.glp().bufferViewer.framebufferTexture2D(args);\n      return original.apply(this, args);\n    },\n    bindRenderbuffer: function(original, args, name) {\n      this.glp().bufferViewer.bindRenderbuffer(args[1]);\n      return original.apply(this, args);\n    },\n    unbindRenderbuffer: function(original, args, name) {\n      this.glp().bufferViewer.unbindRenderbuffer();\n      return original.apply(this, args);\n    },\n    deleteRenderbuffer: function(original, args, name) {\n      this.glp().bufferViewer.deleteRenderbuffer(args[0]);\n      return original.apply(this, args);\n    },\n    pixelStorei: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStates(args[0], args[1])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    depthMask: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStates(this.DEPTH_WRITEMASK, args[0])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    clearDepth: function(original, args, name) {\n      \/\/ range = [0,1]\n      if (this.glp().stateTracker.freezeStates(this.DEPTH_CLEAR_VALUE, args[0])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    lineWidth: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStates(this.LINE_WIDTH, args[0])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    polygonOffset: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStates(this.POLYGON_OFFSET_FACTOR, args[0])) {\n        return;\n      }\n      if (this.glp().stateTracker.freezeStates(this.POLYGON_OFFSET_UNITS, args[1])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    stencilFunc: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStates(this.STENCIL_REF, args[1])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    stencilFuncSeparate: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStencilStates(args[0], args[2])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    blendEquationSeparate: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStates(this.BLEND_EQUATION_RGB, args[0])) {\n        return;\n      }\n      if (this.glp().stateTracker.freezeStates(this.BLEND_EQUATION_ALPHA, args[1])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    cullFace: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStates(this.CULL_FACE_MODE, args[0])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    depthFunc: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStates(this.DEPTH_FUNC, args[0])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    frontFace: function(original, args, name) {\n      if (this.glp().stateTracker.freezeStates(this.FRONT_FACE, args[0])) {\n        return;\n      }\n      return original.apply(this, args);\n    },\n    generateMipmap: function(original, args, name) {\n      this.glp().mipmapViewer.generateMipmap(original, args);\n      return original.apply(this, args);\n    },\n}\n\nvar glpUniformFcn = function(original, args, name) {\n  args = this.glp().pixelInspector.remapLocations(args);\n  args = this.glp().depthInspector.remapLocations(args);\n  return original.apply(this, args);\n}\nvar uniformMethods = [\n    \'uniform1f\', \'uniform1fv\', \'uniform1i\', \'uniform1iv\',\n    \'uniform2f\', \'uniform2fv\', \'uniform2i\', \'uniform2iv\',\n    \'uniform3f\', \'uniform3fv\', \'uniform3i\', \'uniform3iv\',\n    \'uniform4f\', \'uniform4fv\', \'uniform4i\', \'uniform4iv\',\n    \'uniformMatrix2fv\', \'uniformMatrix3fv\', \'uniformMatrix4fv\'\n];\nfor (var i=0; i<uniformMethods.length; i++) {\n    glpFcnBindings[uniformMethods[i]] = glpUniformFcn;\n}\n\/**\n * Returns a function that calls newFunc with origFunc and all arguments\n * @param {Function} origFunc\n * @param {Function} newFunc\n * @param {String} name of origFunc\n * @return {Function} boundFunc\n *\/\nfunction _glpBind(origFunc, newFunc, name) {\n    return function() {\n        return newFunc.apply(this, [origFunc, arguments, name]);\n    }\n}\n\n_glpModuleInstances = {};\n\nfunction bindWebGL() {\n    \/**\n     * Bind WebGLRenderingContext functions to functions found in glpFcnBindings\n     * If defined, functions are first bound the function found in glpFcnBindings\n     * Afterwards, they are then bound to the default func\n     *\/\n    for (var name in WebGLRenderingContext.prototype) {\n        try {\n            if (typeof WebGLRenderingContext.prototype[name] != \'function\') {\n                continue;\n            }\n\n            if (glpFcnBindings[name] != null) {\n                var newFunc = glpFcnBindings[name];\n                WebGLRenderingContext.prototype[name] =\n                    _glpBind(WebGLRenderingContext.prototype[name], newFunc, name);\n            }\n\n            var defaultFunc = glpFcnBindings[\"default\"];\n            WebGLRenderingContext.prototype[name] =\n                _glpBind(WebGLRenderingContext.prototype[name], defaultFunc, name);\n        } catch(err) {\n            \/\/ TODO: Handle binding errors\n        }\n    }\n\n    WebGLRenderingContext.prototype.__newGLP = function() {\n        if (this.__uuid === undefined) {\n            this.__uuid = glpHelpers.guid();\n        }\n\n        var modules = {}\n        modules.bufferViewer = new glpBufferViewer(this);\n        modules.callStack = new glpCallStack(this);\n        modules.frameControl = new glpFrameControl(this, window);\n        modules.duplicateProgramDetection = new glpDuplicateProgramDetection(this);\n        modules.histogram = new glpHistogram(this);\n        modules.messages = new glpMessages(this);\n        modules.pixelInspector = new glpPixelInspector(this);\n        modules.depthInspector = new glpDepthInspector(this);\n        modules.programUsageCounter = new glpProgramUsageCounter(this);\n        modules.stateTracker = new glpStateTracker(this);\n        modules.textureViewer = new glpTextureViewer(this);\n        modules.shaderViewer = new glpShaderViewer(this);\n        modules.mipmapViewer = new glpMipmapViewer(this);\n        _glpModuleInstances[this.__uuid] = modules;\n        return modules;\n    }\n\n    WebGLRenderingContext.prototype.glp = function() {\n        return _glpModuleInstances[this.__uuid] ? _glpModuleInstances[this.__uuid] : this.__newGLP();\n    }\n}\n\nbindWebGL();\n`;
    s.textContent = code_to_inject;
    s.onload = function() {
      this.parentNode.removeChild(this);
    };
    (document.head || document.documentElement).appendChild(s);
  } else {
    // Note: Files are appended in order
    var fileDirectory = "src/content_script/"
    files = [
      "helpers.js",
      "buffer_viewer.js",
      "frame_control.js",
      "program_usage_counter.js",
      "duplicate_program_detection.js",
      "pixel_inspector.js",
      "depth_inspector.js",
      "mipmap_viewer.js",
      "texture_viewer.js",
      "contexts.js",
      "messages.js",
      "message_handling.js",
      "call_stack.js",
      "histogram.js",
      "state_variables.js",
      "shader_viewer.js",
      "fcn_bindings.js",
      "webgl_bind.js",
    ];

    var sharedFileDirectory = "src/shared/"
    sharedFiles = [
      "message_types.js"
    ];

    appendFiles(sharedFileDirectory, sharedFiles)
    appendFiles(fileDirectory, files)

    function appendFiles(directory, files) {
      for (var i=0; i<files.length; i++) {
        // From: http://stackoverflow.com/questions/9515704/building-a-chrome-extension-inject-code-in-a-page-using-a-content-script
        var s = document.createElement('script');
        s.src = chrome.extension.getURL(directory + files[i]);
        s.async = false;
        s.onload = function() {
          this.parentNode.removeChild(this);
        };
        (document.head || document.documentElement).appendChild(s);
      }
    }
  }

  // From: https://developer.chrome.com/extensions/devtools#injecting
  // Use window events to send messages between content script and main.js
  window.addEventListener('message', function(event) {
    // Only accept messages from the same frame
    if (event.source !== window) {
      return;
    }

    var message = event.data;

    // Only accept messages that we know are ours
    if (typeof message !== 'object' || message === null) {
      return;
    }
    chrome.runtime.sendMessage(message);
  });

  chrome.extension.onMessage.addListener(function(msg, sender, sendResponse) {
     window.postMessage(msg, "*");
  });
}

chrome.storage.sync.get({"glpEnabled": false}, function(items) {
  if (items["glpEnabled"]) {
    injectExtension();
  }
})
